# Sveltest Code Examples

## Basic Component Tests

### Simple Button Component Testing
```typescript
// Testing a primary button component
import { describe, expect, test } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import Button from './Button.svelte';

describe('Button Component', () => {
  test('should render with correct text', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<span>Click me</span>`,
    }));

    render(Button, { children });

    const button = page.getByRole('button', { name: 'Click me' });
    await expect.element(button).toBeInTheDocument();
  });

  test('should handle click events', async () => {
    const click_handler = vi.fn();
    const children = createRawSnippet(() => ({
      render: () => `<span>Submit</span>`,
    }));

    render(Button, { onclick: click_handler, children });

    const button = page.getByRole('button', { name: 'Submit' });
    await button.click();

    expect(click_handler).toHaveBeenCalledOnce();
  });

  test('should apply variant styling', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<span>Primary Button</span>`,
    }));

    render(Button, { variant: 'primary', children });

    const button = page.getByRole('button', { name: 'Primary Button' });
    await expect.element(button).toHaveClass('btn-primary');
  });

  test('should support disabled state', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<span>Disabled</span>`,
    }));

    render(Button, { disabled: true, children });

    const button = page.getByRole('button', { name: 'Disabled' });
    await expect.element(button).toBeDisabled();
    await expect.element(button).toHaveClass('btn-disabled');
  });

  test('should handle multiple button variants', async () => {
    const variants = ['primary', 'secondary', 'danger'] as const;
    
    for (const variant of variants) {
      const children = createRawSnippet(() => ({
        render: () => `<span>${variant} button</span>`,
      }));

      render(Button, { variant, children });
      
      const button = page.getByRole('button', { name: `${variant} button` });
      await expect.element(button).toHaveClass(`btn-${variant}`);
    }
  });
});
```

### Icon Component Testing
```typescript
// Testing an icon component with different states
import { describe, expect, test } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import Icon from './Icon.svelte';

describe('Icon Component', () => {
  test('should render with semantic attributes', async () => {
    render(Icon, { name: 'check', label: 'Success' });

    const icon = page.getByRole('img', { name: 'Success' });
    await expect.element(icon).toBeInTheDocument();
    await expect.element(icon).toHaveAttribute('aria-label', 'Success');
  });

  test('should apply size variants', async () => {
    render(Icon, { name: 'star', size: 'lg' });

    const icon = page.getByTestId('icon');
    await expect.element(icon).toHaveClass('h-6 w-6');
  });

  test('should handle color variants', async () => {
    render(Icon, { name: 'warning', color: 'amber' });

    const icon = page.getByTestId('icon');
    await expect.element(icon).toHaveClass('text-amber-500');
  });

  test('should render different icon types', async () => {
    const icons = ['check', 'warning', 'info', 'error'];
    
    for (const icon_name of icons) {
      render(Icon, { name: icon_name, label: `${icon_name} icon` });
      
      const icon = page.getByRole('img', { name: `${icon_name} icon` });
      await expect.element(icon).toBeInTheDocument();
    }
  });
});
```

### Modal Component Testing
```typescript
// Testing a modal dialog component
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import Modal from './Modal.svelte';

describe('Modal Component', () => {
  test('should render when open', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<p>Modal content</p>`,
    }));

    render(Modal, { open: true, title: 'Settings', children });

    const modal = page.getByRole('dialog');
    await expect.element(modal).toBeInTheDocument();
    await expect.element(modal).toHaveAttribute('aria-modal', 'true');
    
    const title = page.getByRole('heading', { level: 2 });
    await expect.element(title).toHaveText('Settings');
  });

  test('should not render when closed', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<p>Modal content</p>`,
    }));

    render(Modal, { open: false, title: 'Settings', children });

    const modal = page.getByRole('dialog');
    await expect.element(modal).not.toBeInTheDocument();
  });

  test('should handle close events', async () => {
    const close_handler = vi.fn();
    const children = createRawSnippet(() => ({
      render: () => `<p>Content</p>`,
    }));

    render(Modal, { open: true, title: 'Test', onclose: close_handler, children });

    const close_button = page.getByRole('button', { name: 'Close' });
    await close_button.click();

    expect(close_handler).toHaveBeenCalledOnce();
  });

  test('should close on escape key', async () => {
    const close_handler = vi.fn();
    const children = createRawSnippet(() => ({
      render: () => `<p>Content</p>`,
    }));

    render(Modal, { open: true, title: 'Test', onclose: close_handler, children });

    await page.keyboard.press('Escape');
    expect(close_handler).toHaveBeenCalledOnce();
  });

  test('should manage focus correctly', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<button>Action</button>`,
    }));

    render(Modal, { open: true, title: 'Focus Test', children });

    const close_button = page.getByRole('button', { name: 'Close' });
    await expect.element(close_button).toBeFocused();

    // Test tab navigation
    await page.keyboard.press('Tab');
    const action_button = page.getByRole('button', { name: 'Action' });
    await expect.element(action_button).toBeFocused();
  });
});
```

## Form Testing Patterns

### Input Component Testing
```typescript
// Testing form input components with validation
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import Input from './Input.svelte';

describe('Input Component', () => {
  test('should render with label', async () => {
    render(Input, { type: 'text', label: 'Full Name', value: '' });

    const input = page.getByLabelText('Full Name');
    await expect.element(input).toBeInTheDocument();
    await expect.element(input).toHaveAttribute('type', 'text');
  });

  test('should handle user input', async () => {
    const input_handler = vi.fn();
    render(Input, { 
      type: 'email', 
      label: 'Email Address', 
      value: '',
      oninput: input_handler 
    });

    const input = page.getByLabelText('Email Address');
    await input.fill('john@example.com');

    await expect.element(input).toHaveValue('john@example.com');
    expect(input_handler).toHaveBeenCalled();
  });

  test('should display validation errors', async () => {
    render(Input, {
      type: 'email',
      label: 'Email',
      value: 'invalid-email',
      error: 'Please enter a valid email address'
    });

    const input = page.getByLabelText('Email');
    const error_message = page.getByText('Please enter a valid email address');

    await expect.element(error_message).toBeInTheDocument();
    await expect.element(input).toHaveAttribute('aria-invalid', 'true');
    await expect.element(input).toHaveClass('input-error');
  });

  test('should support required fields', async () => {
    render(Input, {
      type: 'text',
      label: 'Required Field',
      value: '',
      required: true
    });

    const input = page.getByLabelText('Required Field');
    await expect.element(input).toHaveAttribute('required');
    await expect.element(input).toHaveAttribute('aria-required', 'true');
  });

  test('should handle different input types', async () => {
    const input_types = ['text', 'email', 'password', 'tel', 'url'];
    
    for (const type of input_types) {
      render(Input, { type, label: `${type} input`, value: '' });
      
      const input = page.getByLabelText(`${type} input`);
      await expect.element(input).toHaveAttribute('type', type);
    }
  });

  test('should handle disabled state', async () => {
    render(Input, {
      type: 'text',
      label: 'Disabled Input',
      value: 'Cannot edit',
      disabled: true
    });

    const input = page.getByLabelText('Disabled Input');
    await expect.element(input).toBeDisabled();
    await expect.element(input).toHaveClass('input-disabled');
  });
});
```

### Contact Form Testing
```typescript
// Testing a complete contact form with validation
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import ContactForm from './ContactForm.svelte';

describe('ContactForm', () => {
  test('should render form fields', async () => {
    render(ContactForm);

    await expect.element(page.getByLabelText('Name')).toBeInTheDocument();
    await expect.element(page.getByLabelText('Email')).toBeInTheDocument();
    await expect.element(page.getByLabelText('Message')).toBeInTheDocument();
    await expect.element(page.getByRole('button', { name: 'Send Message' })).toBeInTheDocument();
  });

  test('should submit form with valid data', async () => {
    const submit_handler = vi.fn();
    render(ContactForm, { onsubmit: submit_handler });

    // Fill out form
    await page.getByLabelText('Name').fill('John Doe');
    await page.getByLabelText('Email').fill('john@example.com');
    await page.getByLabelText('Message').fill('Hello, this is a test message.');

    // Submit form
    await page.getByRole('button', { name: 'Send Message' }).click();

    expect(submit_handler).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com',
      message: 'Hello, this is a test message.'
    });
  });

  test('should show validation errors for empty fields', async () => {
    const submit_handler = vi.fn();
    render(ContactForm, { onsubmit: submit_handler });

    // Try to submit empty form
    await page.getByRole('button', { name: 'Send Message' }).click();

    // Should show validation errors
    await expect.element(page.getByText('Name is required')).toBeInTheDocument();
    await expect.element(page.getByText('Email is required')).toBeInTheDocument();
    await expect.element(page.getByText('Message is required')).toBeInTheDocument();

    // Should not call submit handler
    expect(submit_handler).not.toHaveBeenCalled();
  });

  test('should validate email format', async () => {
    render(ContactForm);

    const email_input = page.getByLabelText('Email');
    await email_input.fill('invalid-email');
    await email_input.blur();

    await expect.element(page.getByText('Please enter a valid email address')).toBeInTheDocument();
  });

  test('should clear form after successful submission', async () => {
    const submit_handler = vi.fn();
    render(ContactForm, { onsubmit: submit_handler });

    // Fill and submit form
    await page.getByLabelText('Name').fill('Jane Doe');
    await page.getByLabelText('Email').fill('jane@example.com');
    await page.getByLabelText('Message').fill('Test message');
    await page.getByRole('button', { name: 'Send Message' }).click();

    // Form should be cleared
    await expect.element(page.getByLabelText('Name')).toHaveValue('');
    await expect.element(page.getByLabelText('Email')).toHaveValue('');
    await expect.element(page.getByLabelText('Message')).toHaveValue('');

    // Success message should appear
    await expect.element(page.getByText('Message sent successfully!')).toBeInTheDocument();
  });

  test('should handle form submission loading state', async () => {
    const submit_handler = vi.fn(() => new Promise(resolve => setTimeout(resolve, 1000)));
    render(ContactForm, { onsubmit: submit_handler });

    await page.getByLabelText('Name').fill('Test User');
    await page.getByLabelText('Email').fill('test@example.com');
    await page.getByLabelText('Message').fill('Test message');
    
    const submit_button = page.getByRole('button', { name: 'Send Message' });
    await submit_button.click();

    // Button should show loading state
    await expect.element(page.getByRole('button', { name: 'Sending...' })).toBeInTheDocument();
    await expect.element(submit_button).toBeDisabled();
  });
});
```

### Login Form Testing
```typescript
// Testing authentication form with complete validation flow
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import LoginForm from './LoginForm.svelte';

describe('LoginForm', () => {
  test('should handle successful login', async () => {
    const login_handler = vi.fn(() => Promise.resolve({ success: true }));
    render(LoginForm, { onlogin: login_handler });

    await page.getByLabelText('Email').fill('user@example.com');
    await page.getByLabelText('Password').fill('password123');
    await page.getByRole('button', { name: 'Sign In' }).click();

    expect(login_handler).toHaveBeenCalledWith({
      email: 'user@example.com',
      password: 'password123'
    });

    await expect.element(page.getByText('Welcome back!')).toBeInTheDocument();
  });

  test('should display server error messages', async () => {
    const login_handler = vi.fn(() => 
      Promise.reject({ message: 'Invalid credentials' })
    );
    render(LoginForm, { onlogin: login_handler });

    await page.getByLabelText('Email').fill('wrong@example.com');
    await page.getByLabelText('Password').fill('wrongpassword');
    await page.getByRole('button', { name: 'Sign In' }).click();

    await expect.element(page.getByText('Invalid credentials')).toBeInTheDocument();
  });

  test('should validate form fields on blur', async () => {
    render(LoginForm);

    // Test email validation
    const email_input = page.getByLabelText('Email');
    await email_input.fill('invalid-email');
    await email_input.blur();
    
    await expect.element(page.getByText('Please enter a valid email')).toBeInTheDocument();

    // Test password validation
    const password_input = page.getByLabelText('Password');
    await password_input.fill('123');
    await password_input.blur();
    
    await expect.element(page.getByText('Password must be at least 8 characters')).toBeInTheDocument();
  });

  test('should toggle password visibility', async () => {
    render(LoginForm);

    const password_input = page.getByLabelText('Password');
    const toggle_button = page.getByRole('button', { name: 'Show password' });

    await expect.element(password_input).toHaveAttribute('type', 'password');

    await toggle_button.click();
    await expect.element(password_input).toHaveAttribute('type', 'text');
    await expect.element(page.getByRole('button', { name: 'Hide password' })).toBeInTheDocument();
  });

  test('should handle remember me checkbox', async () => {
    const login_handler = vi.fn();
    render(LoginForm, { onlogin: login_handler });

    const remember_checkbox = page.getByRole('checkbox', { name: 'Remember me' });
    await remember_checkbox.check();
    
    await page.getByLabelText('Email').fill('user@example.com');
    await page.getByLabelText('Password').fill('password123');
    await page.getByRole('button', { name: 'Sign In' }).click();

    expect(login_handler).toHaveBeenCalledWith({
      email: 'user@example.com',
      password: 'password123',
      remember: true
    });
  });
});
```

## State Testing with Runes

### Basic State Management Testing
```typescript
// Testing Svelte 5 $state and $derived values
import { describe, expect, test } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { flushSync, untrack } from 'svelte';
import Counter from './Counter.svelte';

describe('Counter Component State', () => {
  test('should handle $state updates', async () => {
    render(Counter, { initial_count: 0 });

    const count_display = page.getByTestId('count');
    const increment_button = page.getByRole('button', { name: 'Increment' });
    const decrement_button = page.getByRole('button', { name: 'Decrement' });

    // Initial state
    await expect.element(count_display).toHaveTextContent('0');

    // Increment
    await increment_button.click();
    await expect.element(count_display).toHaveTextContent('1');

    // Decrement
    await decrement_button.click();
    await expect.element(count_display).toHaveTextContent('0');
  });

  test('should handle $derived values with untrack', () => {
    let count = $state(0);
    let doubled = $derived(count * 2);
    let is_even = $derived(count % 2 === 0);

    // Test initial values
    expect(untrack(() => doubled)).toBe(0);
    expect(untrack(() => is_even)).toBe(true);

    // Update state
    count = 5;
    flushSync();

    // Test derived values
    expect(untrack(() => doubled)).toBe(10);
    expect(untrack(() => is_even)).toBe(false);
  });

  test('should handle complex derived state', () => {
    let items = $state([]);
    let total_count = $derived(items.length);
    let has_items = $derived(items.length > 0);
    let first_item = $derived(items.length > 0 ? items[0] : null);

    // Initially empty
    expect(untrack(() => total_count)).toBe(0);
    expect(untrack(() => has_items)).toBe(false);
    expect(untrack(() => first_item)).toBe(null);

    // Add items
    items = ['apple', 'banana', 'cherry'];
    flushSync();

    expect(untrack(() => total_count)).toBe(3);
    expect(untrack(() => has_items)).toBe(true);
    expect(untrack(() => first_item)).toBe('apple');
  });
});
```

### Form State Management Testing
```typescript
// Testing complex form state with validation
import { describe, expect, test } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { flushSync, untrack } from 'svelte';
import { create_form_state } from '$lib/utils/form-state';

describe('Form State Management', () => {
  test('should validate form state correctly', () => {
    const form = create_form_state({
      email: { value: '', validation_rules: { required: true } },
      password: { value: '', validation_rules: { required: true, min_length: 8 } }
    });

    // Test initial state - should be valid (no validation run)
    expect(untrack(() => form.is_form_valid())).toBe(true);
    expect(untrack(() => form.has_changes())).toBe(false);
    expect(untrack(() => form.field_errors())).toEqual({});

    // Update field with invalid data
    form.update_field('email', 'invalid');
    flushSync();

    expect(untrack(() => form.has_changes())).toBe(true);
    
    // Trigger validation
    form.validate_all_fields();
    flushSync();

    expect(untrack(() => form.is_form_valid())).toBe(false);
    const errors = untrack(() => form.field_errors());
    expect(errors.email).toBe('Invalid email format');
    expect(errors.password).toBe('Password is required');
  });

  test('should handle field-level validation lifecycle', () => {
    let email = $state('');
    let email_touched = $state(false);
    let submit_attempted = $state(false);

    const email_validation = $derived(() => {
      if (!email) return { is_valid: false, error: 'Email is required' };
      const email_regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!email_regex.test(email)) return { is_valid: false, error: 'Invalid email format' };
      return { is_valid: true, error: '' };
    });

    const show_email_error = $derived(submit_attempted || email_touched);
    const email_error = $derived(() => {
      const validation = email_validation();
      return show_email_error && !validation.is_valid ? validation.error : '';
    });

    // Initially no errors shown
    expect(untrack(() => show_email_error)).toBe(false);
    expect(untrack(() => email_error())).toBe('');

    // Touch field with invalid email
    email = 'invalid';
    email_touched = true;
    flushSync();

    expect(untrack(() => show_email_error)).toBe(true);
    expect(untrack(() => email_error())).toBe('Invalid email format');

    // Fix email
    email = 'user@example.com';
    flushSync();

    expect(untrack(() => email_error())).toBe('');
    expect(untrack(() => email_validation().is_valid)).toBe(true);
  });

  test('should handle form submission state', () => {
    let email = $state('');
    let password = $state('');
    let is_submitting = $state(false);
    let submit_attempted = $state(false);

    const form_is_valid = $derived(() => {
      return email.includes('@') && password.length >= 8;
    });

    const can_submit = $derived(() => {
      return untrack(() => form_is_valid()) && !is_submitting;
    });

    // Initially cannot submit
    expect(untrack(() => can_submit())).toBe(false);

    // Fill valid data
    email = 'test@example.com';
    password = 'validpassword';
    flushSync();

    expect(untrack(() => can_submit())).toBe(true);

    // Start submitting
    is_submitting = true;
    flushSync();

    expect(untrack(() => can_submit())).toBe(false);
  });
});
```

### Shopping Cart State Testing
```typescript
// Testing complex state management with multiple derived values
import { describe, expect, test } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { flushSync, untrack } from 'svelte';
import ShoppingCart from './ShoppingCart.svelte';

describe('Shopping Cart State', () => {
  test('should manage cart items correctly', async () => {
    render(ShoppingCart);

    // Initially empty
    const empty_message = page.getByText('Your cart is empty');
    await expect.element(empty_message).toBeInTheDocument();

    // Add item
    const add_button = page.getByRole('button', { name: 'Add Apple to cart' });
    await add_button.click();

    const cart_item = page.getByText('Apple');
    await expect.element(cart_item).toBeInTheDocument();
    await expect.element(empty_message).not.toBeInTheDocument();
  });

  test('should calculate totals correctly', () => {
    let cart_items = $state([]);
    
    const total_quantity = $derived(
      cart_items.reduce((sum, item) => sum + item.quantity, 0)
    );
    
    const total_price = $derived(
      cart_items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
    );
    
    const has_items = $derived(cart_items.length > 0);

    // Initially empty
    expect(untrack(() => total_quantity)).toBe(0);
    expect(untrack(() => total_price)).toBe(0);
    expect(untrack(() => has_items)).toBe(false);

    // Add items
    cart_items = [
      { id: 1, name: 'Apple', price: 1.50, quantity: 2 },
      { id: 2, name: 'Banana', price: 0.75, quantity: 3 }
    ];
    flushSync();

    expect(untrack(() => total_quantity)).toBe(5);
    expect(untrack(() => total_price)).toBe(5.25); // (1.50 * 2) + (0.75 * 3)
    expect(untrack(() => has_items)).toBe(true);
  });

  test('should handle item quantity updates', () => {
    let cart_items = $state([
      { id: 1, name: 'Apple', price: 1.00, quantity: 1 }
    ]);

    const update_quantity = (item_id, new_quantity) => {
      cart_items = cart_items.map(item =>
        item.id === item_id ? { ...item, quantity: new_quantity } : item
      );
    };

    const remove_item = (item_id) => {
      cart_items = cart_items.filter(item => item.id !== item_id);
    };

    const total_items = $derived(cart_items.length);
    const total_quantity = $derived(
      cart_items.reduce((sum, item) => sum + item.quantity, 0)
    );

    // Initial state
    expect(untrack(() => total_items)).toBe(1);
    expect(untrack(() => total_quantity)).toBe(1);

    // Update quantity
    update_quantity(1, 5);
    flushSync();

    expect(untrack(() => total_items)).toBe(1);
    expect(untrack(() => total_quantity)).toBe(5);

    // Remove item
    remove_item(1);
    flushSync();

    expect(untrack(() => total_items)).toBe(0);
    expect(untrack(() => total_quantity)).toBe(0);
  });
});
```

## SSR Testing Examples

### Component SSR Rendering
```typescript
// Testing server-side rendering of components
import { render } from 'svelte/server';
import { describe, expect, test } from 'vitest';
import HomePage from './HomePage.svelte';
import UserCard from './UserCard.svelte';
import Navigation from './Navigation.svelte';

describe('HomePage SSR', () => {
  test('should render without errors', () => {
    expect(() => {
      render(HomePage);
    }).not.toThrow();
  });

  test('should render essential content for SEO', () => {
    const { body } = render(HomePage, {
      props: { 
        title: 'Welcome to Our Site',
        description: 'The best place for amazing content'
      }
    });

    expect(body).toContain('<h1>Welcome to Our Site</h1>');
    expect(body).toContain('The best place for amazing content');
    expect(body).toContain('<main');
    expect(body).toContain('role="main"');
  });

  test('should render meta information', () => {
    const { head } = render(HomePage, {
      props: { 
        title: 'Amazing Site',
        description: 'Site description for SEO'
      }
    });

    expect(head).toContain('<title>Amazing Site</title>');
    expect(head).toContain('meta name="description"');
    expect(head).toContain('Site description for SEO');
  });

  test('should include structured data', () => {
    const { head } = render(HomePage, {
      props: {
        structured_data: {
          '@type': 'Organization',
          name: 'Test Company'
        }
      }
    });

    expect(head).toContain('application/ld+json');
    expect(head).toContain('Test Company');
  });
});

describe('UserCard SSR', () => {
  test('should render user information', () => {
    const user = {
      id: '123',
      name: 'John Doe',
      email: 'john@example.com',
      avatar: '/images/john.jpg',
      role: 'Developer'
    };

    const { body } = render(UserCard, { props: { user } });

    expect(body).toContain('John Doe');
    expect(body).toContain('john@example.com');
    expect(body).toContain('Developer');
    expect(body).toContain('src="/images/john.jpg"');
    expect(body).toContain('alt="John Doe"');
  });

  test('should handle missing user data gracefully', () => {
    const { body } = render(UserCard, { 
      props: { user: null } 
    });

    expect(body).toContain('User not found');
    expect(body).not.toContain('undefined');
    expect(body).not.toContain('null');
  });

  test('should render accessibility attributes', () => {
    const user = {
      id: '456',
      name: 'Jane Smith',
      email: 'jane@example.com'
    };

    const { body } = render(UserCard, { props: { user } });

    expect(body).toContain('role="article"');
    expect(body).toContain('aria-label');
    expect(body).toContain('itemscope');
    expect(body).toContain('itemtype="http://schema.org/Person"');
  });
});

describe('Navigation SSR', () => {
  test('should render navigation structure', () => {
    const { body } = render(Navigation, {
      props: {
        current_path: '/docs'
      }
    });

    expect(body).toContain('<nav');
    expect(body).toContain('role="navigation"');
    expect(body).toContain('aria-label="Main navigation"');
    expect(body).toContain('href="/docs"');
    expect(body).toContain('href="/examples"');
    expect(body).toContain('href="/about"');
  });

  test('should highlight active navigation item', () => {
    const { body } = render(Navigation, {
      props: {
        current_path: '/examples'
      }
    });

    expect(body).toContain('aria-current="page"');
    expect(body).toContain('nav-active');
  });

  test('should include skip navigation link', () => {
    const { body } = render(Navigation);

    expect(body).toContain('href="#main-content"');
    expect(body).toContain('Skip to main content');
    expect(body).toContain('sr-only');
  });
});
```

### Layout SSR Testing
```typescript
// Testing layout components for SSR compatibility
import { render } from 'svelte/server';
import { describe, expect, test } from 'vitest';
import Layout from './Layout.svelte';
import Footer from './Footer.svelte';
import Header from './Header.svelte';

describe('Layout SSR', () => {
  test('should render complete page structure', () => {
    const { body } = render(Layout, {
      props: {
        title: 'Test Page',
        description: 'Test description'
      }
    });

    expect(body).toContain('<!DOCTYPE html>');
    expect(body).toContain('<html lang="en"');
    expect(body).toContain('<head>');
    expect(body).toContain('<body>');
    expect(body).toContain('<header>');
    expect(body).toContain('<main>');
    expect(body).toContain('<footer>');
  });

  test('should include essential meta tags', () => {
    const { head } = render(Layout, {
      props: {
        title: 'SEO Test Page',
        description: 'This is a test page for SEO',
        canonical_url: 'https://example.com/test'
      }
    });

    expect(head).toContain('<title>SEO Test Page</title>');
    expect(head).toContain('name="description" content="This is a test page for SEO"');
    expect(head).toContain('name="viewport" content="width=device-width, initial-scale=1"');
    expect(head).toContain('rel="canonical" href="https://example.com/test"');
  });

  test('should render Open Graph tags', () => {
    const { head } = render(Layout, {
      props: {
        title: 'Social Share Test',
        description: 'Test for social sharing',
        og_image: '/images/social-share.jpg'
      }
    });

    expect(head).toContain('property="og:title" content="Social Share Test"');
    expect(head).toContain('property="og:description" content="Test for social sharing"');
    expect(head).toContain('property="og:image" content="/images/social-share.jpg"');
    expect(head).toContain('property="og:type" content="website"');
  });

  test('should include accessibility features', () => {
    const { body } = render(Layout);

    expect(body).toContain('role="banner"'); // Header
    expect(body).toContain('role="main"'); // Main content
    expect(body).toContain('role="contentinfo"'); // Footer
    expect(body).toContain('skip-link');
    expect(body).toContain('aria-label');
  });
});

describe('Header SSR', () => {
  test('should render site branding', () => {
    const { body } = render(Header, {
      props: {
        site_name: 'Test Site',
        logo_url: '/logo.svg'
      }
    });

    expect(body).toContain('Test Site');
    expect(body).toContain('src="/logo.svg"');
    expect(body).toContain('alt="Test Site"');
  });

  test('should render navigation menu', () => {
    const navigation_items = [
      { href: '/home', label: 'Home' },
      { href: '/about', label: 'About' },
      { href: '/contact', label: 'Contact' }
    ];

    const { body } = render(Header, {
      props: { navigation_items }
    });

    expect(body).toContain('href="/home"');
    expect(body).toContain('href="/about"');
    expect(body).toContain('href="/contact"');
    expect(body).toContain('>Home<');
    expect(body).toContain('>About<');
    expect(body).toContain('>Contact<');
  });
});

describe('Footer SSR', () => {
  test('should render footer information', () => {
    const { body } = render(Footer, {
      props: {
        company_name: 'Test Company',
        copyright_year: 2024
      }
    });

    expect(body).toContain('<footer');
    expect(body).toContain('© 2024 Test Company');
    expect(body).toContain('role="contentinfo"');
  });

  test('should render footer links', () => {
    const footer_links = [
      { href: '/privacy', label: 'Privacy Policy' },
      { href: '/terms', label: 'Terms of Service' },
      { href: '/contact', label: 'Contact Us' }
    ];

    const { body } = render(Footer, {
      props: { footer_links }
    });

    expect(body).toContain('href="/privacy"');
    expect(body).toContain('Privacy Policy');
    expect(body).toContain('href="/terms"');
    expect(body).toContain('Terms of Service');
  });

  test('should include social media links', () => {
    const social_links = [
      { platform: 'twitter', url: 'https://twitter.com/testcompany' },
      { platform: 'github', url: 'https://github.com/testcompany' }
    ];

    const { body } = render(Footer, {
      props: { social_links }
    });

    expect(body).toContain('https://twitter.com/testcompany');
    expect(body).toContain('https://github.com/testcompany');
    expect(body).toContain('aria-label="Twitter"');
    expect(body).toContain('aria-label="GitHub"');
  });
});
```

## Mocking Examples

### Utility Function Mocking
```typescript
// Mocking utility functions with realistic return values
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import UserProfile from './UserProfile.svelte';

// Mock API utilities
vi.mock('$lib/utils/api', () => ({
  fetch_user_data: vi.fn(() =>
    Promise.resolve({
      id: '123',
      name: 'John Doe',
      email: 'john@example.com',
      avatar: '/images/john.jpg',
      status: 'active'
    })
  ),
  update_user_profile: vi.fn(() =>
    Promise.resolve({ success: true, message: 'Profile updated' })
  )
}));

// Mock validation utilities
vi.mock('$lib/utils/validation', () => ({
  validate_email: vi.fn((email: string) => ({
    is_valid: email.includes('@'),
    error_message: email.includes('@') ? '' : 'Invalid email format'
  })),
  validate_password: vi.fn((password: string) => ({
    is_valid: password.length >= 8,
    error_message: password.length >= 8 ? '' : 'Password must be at least 8 characters'
  }))
}));

describe('UserProfile with Mocked Utilities', () => {
  test('should load user data on mount', async () => {
    render(UserProfile, { user_id: '123' });

    // Wait for async data loading
    await expect.element(page.getByText('John Doe')).toBeInTheDocument();
    await expect.element(page.getByText('john@example.com')).toBeInTheDocument();
    
    const { fetch_user_data } = await import('$lib/utils/api');
    expect(fetch_user_data).toHaveBeenCalledWith('123');
  });

  test('should validate email input', async () => {
    render(UserProfile, { user_id: '123' });

    const email_input = page.getByLabelText('Email');
    await email_input.fill('invalid-email');
    await email_input.blur();

    const { validate_email } = await import('$lib/utils/validation');
    expect(validate_email).toHaveBeenCalledWith('invalid-email');
    
    await expect.element(page.getByText('Invalid email format')).toBeInTheDocument();
  });

  test('should handle profile update', async () => {
    render(UserProfile, { user_id: '123' });

    await page.getByLabelText('Name').fill('Jane Doe');
    await page.getByLabelText('Email').fill('jane@example.com');
    await page.getByRole('button', { name: 'Save Changes' }).click();

    const { update_user_profile } = await import('$lib/utils/api');
    expect(update_user_profile).toHaveBeenCalledWith('123', {
      name: 'Jane Doe',
      email: 'jane@example.com'
    });

    await expect.element(page.getByText('Profile updated')).toBeInTheDocument();
  });

  test('should verify mocks are working correctly', async () => {
    const { fetch_user_data, update_user_profile } = await import('$lib/utils/api');
    const { validate_email, validate_password } = await import('$lib/utils/validation');

    // Verify all functions are mocked
    expect(vi.isMockFunction(fetch_user_data)).toBe(true);
    expect(vi.isMockFunction(update_user_profile)).toBe(true);
    expect(vi.isMockFunction(validate_email)).toBe(true);
    expect(vi.isMockFunction(validate_password)).toBe(true);

    // Test mock return values
    const user_data = await fetch_user_data('test-id');
    expect(user_data).toEqual({
      id: '123',
      name: 'John Doe',
      email: 'john@example.com',
      avatar: '/images/john.jpg',
      status: 'active'
    });

    const email_validation = validate_email('test@example.com');
    expect(email_validation).toEqual({
      is_valid: true,
      error_message: ''
    });
  });
});
```

### Component Mocking
```typescript
// Mocking child components to isolate testing
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import Dashboard from './Dashboard.svelte';

// Mock heavy chart component
vi.mock('$lib/components/Chart.svelte', () => ({
  default: vi.fn().mockImplementation(() => ({
    $$: {},
    $set: vi.fn(),
    $destroy: vi.fn(),
    $on: vi.fn()
  }))
}));

// Mock data table component
vi.mock('$lib/components/DataTable.svelte', () => ({
  default: vi.fn().mockImplementation(() => ({
    $$: {},
    $set: vi.fn(),
    $destroy: vi.fn(),
    $on: vi.fn()
  }))
}));

describe('Dashboard with Mocked Components', () => {
  test('should render dashboard layout without heavy components', async () => {
    render(Dashboard, {
      user_data: { name: 'Test User' },
      dashboard_data: { metrics: [], charts: [] }
    });

    // Test dashboard structure without loading heavy components
    await expect.element(page.getByText('Dashboard')).toBeInTheDocument();
    await expect.element(page.getByText('Welcome, Test User')).toBeInTheDocument();
    await expect.element(page.getByTestId('dashboard-header')).toBeInTheDocument();
  });

  test('should handle dashboard actions', async () => {
    const refresh_handler = vi.fn();
    render(Dashboard, {
      user_data: { name: 'Test User' },
      onrefresh: refresh_handler
    });

    const refresh_button = page.getByRole('button', { name: 'Refresh Data' });
    await refresh_button.click();

    expect(refresh_handler).toHaveBeenCalledOnce();
  });

  test('should show loading state', async () => {
    render(Dashboard, {
      user_data: { name: 'Test User' },
      is_loading: true
    });

    await expect.element(page.getByText('Loading dashboard...')).toBeInTheDocument();
    await expect.element(page.getByTestId('loading-spinner')).toBeInTheDocument();
  });
});
```

### Store Mocking
```typescript
// Mocking Svelte stores for predictable test state
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import UserDashboard from './UserDashboard.svelte';

// Mock user store
vi.mock('$lib/stores/user', () => ({
  user_store: {
    subscribe: vi.fn((callback) => {
      callback({
        id: '123',
        name: 'Test User',
        email: 'test@example.com',
        role: 'admin',
        preferences: { theme: 'dark' }
      });
      return vi.fn(); // Unsubscribe function
    }),
    set: vi.fn(),
    update: vi.fn()
  }
}));

// Mock notifications store
vi.mock('$lib/stores/notifications', () => ({
  notifications_store: {
    subscribe: vi.fn((callback) => {
      callback([
        { id: '1', message: 'Welcome back!', type: 'success' },
        { id: '2', message: 'You have 3 new messages', type: 'info' }
      ]);
      return vi.fn();
    }),
    add: vi.fn(),
    remove: vi.fn(),
    clear: vi.fn()
  }
}));

describe('UserDashboard with Mocked Stores', () => {
  test('should display user information from store', async () => {
    render(UserDashboard);

    await expect.element(page.getByText('Test User')).toBeInTheDocument();
    await expect.element(page.getByText('test@example.com')).toBeInTheDocument();
    await expect.element(page.getByText('admin')).toBeInTheDocument();
  });

  test('should display notifications from store', async () => {
    render(UserDashboard);

    await expect.element(page.getByText('Welcome back!')).toBeInTheDocument();
    await expect.element(page.getByText('You have 3 new messages')).toBeInTheDocument();
  });

  test('should handle theme preference', async () => {
    render(UserDashboard);

    const dashboard = page.getByTestId('user-dashboard');
    await expect.element(dashboard).toHaveClass('theme-dark');
  });

  test('should handle notification actions', async () => {
    render(UserDashboard);

    const close_button = page.getByRole('button', { name: 'Close notification' }).first();
    await close_button.click();

    const { notifications_store } = await import('$lib/stores/notifications');
    expect(notifications_store.remove).toHaveBeenCalledWith('1');
  });
});
```

## Error Handling and Troubleshooting Examples

### Async Error Handling
```typescript
// Testing components with async operations and error states
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import AsyncDataComponent from './AsyncDataComponent.svelte';

describe('Async Error Handling', () => {
  test('should handle loading states', async () => {
    // Mock slow API call
    vi.mock('$lib/api', () => ({
      fetch_data: vi.fn(() => new Promise(resolve => 
        setTimeout(() => resolve({ data: 'test' }), 1000)
      ))
    }));

    render(AsyncDataComponent, { data_id: '123' });

    // Should show loading initially
    await expect.element(page.getByText('Loading...')).toBeInTheDocument();
    await expect.element(page.getByTestId('loading-spinner')).toBeInTheDocument();

    // Wait for data to load
    await expect.element(page.getByText('Data loaded successfully')).toBeInTheDocument();
    await expect.element(page.getByText('Loading...')).not.toBeInTheDocument();
  });

  test('should handle API errors gracefully', async () => {
    // Mock API to throw error
    vi.mock('$lib/api', () => ({
      fetch_data: vi.fn(() => Promise.reject(new Error('Network error')))
    }));

    render(AsyncDataComponent, { data_id: '123' });

    await expect.element(page.getByText('Error: Network error')).toBeInTheDocument();
    await expect.element(page.getByRole('button', { name: 'Retry' })).toBeInTheDocument();
  });

  test('should handle retry functionality', async () => {
    let call_count = 0;
    vi.mock('$lib/api', () => ({
      fetch_data: vi.fn(() => {
        call_count++;
        if (call_count === 1) {
          return Promise.reject(new Error('Temporary error'));
        }
        return Promise.resolve({ data: 'success' });
      })
    }));

    render(AsyncDataComponent, { data_id: '123' });

    // First call fails
    await expect.element(page.getByText('Error: Temporary error')).toBeInTheDocument();

    // Retry succeeds
    const retry_button = page.getByRole('button', { name: 'Retry' });
    await retry_button.click();

    await expect.element(page.getByText('Data loaded successfully')).toBeInTheDocument();
    await expect.element(page.getByText('Error: Temporary error')).not.toBeInTheDocument();
  });

  test('should handle timeout errors', async () => {
    vi.mock('$lib/api', () => ({
      fetch_data: vi.fn(() => new Promise((resolve, reject) => {
        setTimeout(() => reject(new Error('Request timeout')), 5000);
      }))
    }));

    render(AsyncDataComponent, { data_id: '123', timeout: 1000 });

    await expect.element(page.getByText('Request timeout')).toBeInTheDocument();
  });
});
```

### Form Error Handling
```typescript
// Testing form components with various error scenarios
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import RegistrationForm from './RegistrationForm.svelte';

describe('Form Error Handling', () => {
  test('should display client-side validation errors', async () => {
    render(RegistrationForm);

    const email_input = page.getByLabelText('Email');
    const password_input = page.getByLabelText('Password');
    const submit_button = page.getByRole('button', { name: 'Register' });

    // Fill invalid data
    await email_input.fill('invalid-email');
    await password_input.fill('123');
    await submit_button.click();

    // Should show validation errors
    await expect.element(page.getByText('Please enter a valid email address')).toBeInTheDocument();
    await expect.element(page.getByText('Password must be at least 8 characters')).toBeInTheDocument();
  });

  test('should display server errors', async () => {
    const submit_handler = vi.fn().mockRejectedValueOnce({
      message: 'Registration failed',
      field_errors: { 
        email: 'Email already exists',
        username: 'Username is taken'
      }
    });

    render(RegistrationForm, { onsubmit: submit_handler });

    await page.getByLabelText('Email').fill('existing@example.com');
    await page.getByLabelText('Username').fill('taken_username');
    await page.getByLabelText('Password').fill('validpassword');
    await page.getByRole('button', { name: 'Register' }).click();

    // Should show server errors
    await expect.element(page.getByText('Registration failed')).toBeInTheDocument();
    await expect.element(page.getByText('Email already exists')).toBeInTheDocument();
    await expect.element(page.getByText('Username is taken')).toBeInTheDocument();
  });

  test('should handle network errors', async () => {
    const submit_handler = vi.fn().mockRejectedValueOnce(
      new Error('Network connection failed')
    );

    render(RegistrationForm, { onsubmit: submit_handler });

    await page.getByLabelText('Email').fill('user@example.com');
    await page.getByLabelText('Password').fill('password123');
    await page.getByRole('button', { name: 'Register' }).click();

    await expect.element(page.getByText('Network connection failed')).toBeInTheDocument();
    await expect.element(page.getByText('Please check your internet connection and try again')).toBeInTheDocument();
  });

  test('should clear errors when user corrects input', async () => {
    render(RegistrationForm);

    const email_input = page.getByLabelText('Email');
    const submit_button = page.getByRole('button', { name: 'Register' });

    // Trigger validation error
    await email_input.fill('invalid');
    await submit_button.click();
    await expect.element(page.getByText('Please enter a valid email address')).toBeInTheDocument();

    // Fix the error
    await email_input.clear();
    await email_input.fill('valid@example.com');
    await email_input.blur();

    // Error should be cleared
    await expect.element(page.getByText('Please enter a valid email address')).not.toBeInTheDocument();
  });

  test('should handle form submission timeout', async () => {
    const submit_handler = vi.fn(() => new Promise(() => {})); // Never resolves

    render(RegistrationForm, { onsubmit: submit_handler, timeout: 2000 });

    await page.getByLabelText('Email').fill('user@example.com');
    await page.getByLabelText('Password').fill('password123');
    await page.getByRole('button', { name: 'Register' }).click();

    // Should show timeout error
    await expect.element(page.getByText('Request timed out')).toBeInTheDocument();
    await expect.element(page.getByText('Please try again')).toBeInTheDocument();
  });
});
```

### Component Error Boundaries
```typescript
// Testing error boundary components and error recovery
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import ErrorBoundary from './ErrorBoundary.svelte';

describe('Error Boundary Handling', () => {
  test('should catch and display component errors', async () => {
    // Mock console.error to avoid test noise
    const console_error = vi.spyOn(console, 'error').mockImplementation(() => {});

    const failing_component = createRawSnippet(() => ({
      render: () => {
        throw new Error('Component crashed!');
      }
    }));

    render(ErrorBoundary, { children: failing_component });

    await expect.element(page.getByText('Something went wrong')).toBeInTheDocument();
    await expect.element(page.getByText('Component crashed!')).toBeInTheDocument();
    await expect.element(page.getByRole('button', { name: 'Try again' })).toBeInTheDocument();

    console_error.mockRestore();
  });

  test('should handle error recovery', async () => {
    let should_fail = true;
    const console_error = vi.spyOn(console, 'error').mockImplementation(() => {});

    const sometimes_failing_component = createRawSnippet(() => ({
      render: () => {
        if (should_fail) {
          throw new Error('Temporary failure');
        }
        return '<p>Component working!</p>';
      }
    }));

    render(ErrorBoundary, { children: sometimes_failing_component });

    // Should show error initially
    await expect.element(page.getByText('Something went wrong')).toBeInTheDocument();

    // Fix the component and retry
    should_fail = false;
    const retry_button = page.getByRole('button', { name: 'Try again' });
    await retry_button.click();

    // Should show working component
    await expect.element(page.getByText('Component working!')).toBeInTheDocument();
    await expect.element(page.getByText('Something went wrong')).not.toBeInTheDocument();

    console_error.mockRestore();
  });

  test('should log errors for debugging', async () => {
    const console_error = vi.spyOn(console, 'error').mockImplementation(() => {});
    
    const failing_component = createRawSnippet(() => ({
      render: () => {
        throw new Error('Test error for logging');
      }
    }));

    render(ErrorBoundary, { children: failing_component });

    expect(console_error).toHaveBeenCalledWith(
      expect.stringContaining('Test error for logging')
    );

    console_error.mockRestore();
  });
});
```

## Async Testing Patterns

### Promise-based Operations
```typescript
// Testing components with async operations and promises
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import DataFetcher from './DataFetcher.svelte';

describe('Async Promise Operations', () => {
  test('should handle successful async data loading', async () => {
    const mock_data = {
      users: [
        { id: 1, name: 'John Doe' },
        { id: 2, name: 'Jane Smith' }
      ]
    };

    vi.mock('$lib/api', () => ({
      fetch_users: vi.fn(() => Promise.resolve(mock_data))
    }));

    render(DataFetcher, { endpoint: 'users' });

    // Initially shows loading
    await expect.element(page.getByText('Loading users...')).toBeInTheDocument();

    // Wait for data to load
    await expect.element(page.getByText('John Doe')).toBeInTheDocument();
    await expect.element(page.getByText('Jane Smith')).toBeInTheDocument();
    await expect.element(page.getByText('Loading users...')).not.toBeInTheDocument();
  });

  test('should handle async operation failures', async () => {
    vi.mock('$lib/api', () => ({
      fetch_users: vi.fn(() => Promise.reject(new Error('API Error')))
    }));

    render(DataFetcher, { endpoint: 'users' });

    await expect.element(page.getByText('Error loading users: API Error')).toBeInTheDocument();
    await expect.element(page.getByRole('button', { name: 'Retry' })).toBeInTheDocument();
  });

  test('should handle multiple async operations', async () => {
    vi.mock('$lib/api', () => ({
      fetch_users: vi.fn(() => Promise.resolve({ users: [] })),
      fetch_posts: vi.fn(() => Promise.resolve({ posts: [] })),
      fetch_comments: vi.fn(() => Promise.resolve({ comments: [] }))
    }));

    render(DataFetcher, { 
      endpoints: ['users', 'posts', 'comments'] 
    });

    // Should show loading for all endpoints
    await expect.element(page.getByText('Loading 3 data sources...')).toBeInTheDocument();

    // Wait for all to complete
    await expect.element(page.getByText('All data loaded successfully')).toBeInTheDocument();

    // Verify all API calls were made
    const { fetch_users, fetch_posts, fetch_comments } = await import('$lib/api');
    expect(fetch_users).toHaveBeenCalled();
    expect(fetch_posts).toHaveBeenCalled();
    expect(fetch_comments).toHaveBeenCalled();
  });

  test('should handle partial failures in multiple async operations', async () => {
    vi.mock('$lib/api', () => ({
      fetch_users: vi.fn(() => Promise.resolve({ users: [{ id: 1, name: 'John' }] })),
      fetch_posts: vi.fn(() => Promise.reject(new Error('Posts failed'))),
      fetch_comments: vi.fn(() => Promise.resolve({ comments: [] }))
    }));

    render(DataFetcher, { 
      endpoints: ['users', 'posts', 'comments'] 
    });

    await expect.element(page.getByText('John')).toBeInTheDocument();
    await expect.element(page.getByText('Error loading posts: Posts failed')).toBeInTheDocument();
    await expect.element(page.getByText('Comments: 0')).toBeInTheDocument();
  });
});
```

### Real-time Data Updates
```typescript
// Testing components with WebSocket or real-time updates
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import LiveDataComponent from './LiveDataComponent.svelte';

describe('Real-time Data Updates', () => {
  test('should handle WebSocket connection and updates', async () => {
    // Mock WebSocket
    const mock_ws = {
      send: vi.fn(),
      close: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn()
    };

    global.WebSocket = vi.fn(() => mock_ws);

    render(LiveDataComponent, { url: 'ws://localhost:8080' });

    // Should show connecting state
    await expect.element(page.getByText('Connecting...')).toBeInTheDocument();

    // Simulate connection opened
    const connect_handler = mock_ws.addEventListener.mock.calls
      .find(call => call[0] === 'open')?.[1];
    connect_handler?.();

    await expect.element(page.getByText('Connected')).toBeInTheDocument();
    await expect.element(page.getByText('Connecting...')).not.toBeInTheDocument();
  });

  test('should handle incoming WebSocket messages', async () => {
    const mock_ws = {
      send: vi.fn(),
      close: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn()
    };

    global.WebSocket = vi.fn(() => mock_ws);

    render(LiveDataComponent, { url: 'ws://localhost:8080' });

    // Simulate message received
    const message_handler = mock_ws.addEventListener.mock.calls
      .find(call => call[0] === 'message')?.[1];
    
    message_handler?.({
      data: JSON.stringify({
        type: 'update',
        payload: { count: 42, status: 'active' }
      })
    });

    await expect.element(page.getByText('Count: 42')).toBeInTheDocument();
    await expect.element(page.getByText('Status: active')).toBeInTheDocument();
  });

  test('should handle WebSocket connection errors', async () => {
    const mock_ws = {
      send: vi.fn(),
      close: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn()
    };

    global.WebSocket = vi.fn(() => mock_ws);

    render(LiveDataComponent, { url: 'ws://localhost:8080' });

    // Simulate connection error
    const error_handler = mock_ws.addEventListener.mock.calls
      .find(call => call[0] === 'error')?.[1];
    error_handler?.();

    await expect.element(page.getByText('Connection failed')).toBeInTheDocument();
    await expect.element(page.getByRole('button', { name: 'Reconnect' })).toBeInTheDocument();
  });

  test('should handle automatic reconnection', async () => {
    const mock_ws = {
      send: vi.fn(),
      close: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn()
    };

    global.WebSocket = vi.fn(() => mock_ws);

    render(LiveDataComponent, { 
      url: 'ws://localhost:8080',
      auto_reconnect: true,
      reconnect_interval: 100
    });

    // Simulate connection lost
    const close_handler = mock_ws.addEventListener.mock.calls
      .find(call => call[0] === 'close')?.[1];
    close_handler?.();

    await expect.element(page.getByText('Reconnecting...')).toBeInTheDocument();

    // Wait for reconnection attempt
    await new Promise(resolve => setTimeout(resolve, 150));
    
    expect(global.WebSocket).toHaveBeenCalledTimes(2);
  });
});
```

### Async Form Submissions
```typescript
// Testing forms with async submission and validation
import { describe, expect, test, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import AsyncForm from './AsyncForm.svelte';

describe('Async Form Submissions', () => {
  test('should handle successful async form submission', async () => {
    const submit_handler = vi.fn(() => 
      Promise.resolve({ success: true, message: 'Data saved successfully' })
    );

    render(AsyncForm, { onsubmit: submit_handler });

    await page.getByLabelText('Title').fill('Test Title');
    await page.getByLabelText('Description').fill('Test Description');
    
    const submit_button = page.getByRole('button', { name: 'Save' });
    await submit_button.click();

    // Should show loading state
    await expect.element(page.getByText('Saving...')).toBeInTheDocument();
    await expect.element(submit_button).toBeDisabled();

    // Wait for success
    await expect.element(page.getByText('Data saved successfully')).toBeInTheDocument();
    await expect.element(page.getByText('Saving...')).not.toBeInTheDocument();
    await expect.element(submit_button).toBeEnabled();
  });

  test('should handle async validation during submission', async () => {
    const validate_async = vi.fn(() => 
      Promise.resolve({ valid: false, errors: { title: 'Title already exists' } })
    );

    const submit_handler = vi.fn();

    render(AsyncForm, { 
      onsubmit: submit_handler,
      async_validation: validate_async
    });

    await page.getByLabelText('Title').fill('Duplicate Title');
    await page.getByRole('button', { name: 'Save' }).click();

    // Should show validating state
    await expect.element(page.getByText('Validating...')).toBeInTheDocument();

    // Should show validation error
    await expect.element(page.getByText('Title already exists')).toBeInTheDocument();
    
    // Should not call submit handler
    expect(submit_handler).not.toHaveBeenCalled();
  });

  test('should handle concurrent form submissions', async () => {
    let resolve_first_submit;
    const first_submit = new Promise(resolve => {
      resolve_first_submit = resolve;
    });

    const submit_handler = vi.fn(() => first_submit);

    render(AsyncForm, { onsubmit: submit_handler });

    await page.getByLabelText('Title').fill('Test');
    
    const submit_button = page.getByRole('button', { name: 'Save' });
    
    // Start first submission
    await submit_button.click();
    await expect.element(submit_button).toBeDisabled();

    // Try to submit again (should be prevented)
    await submit_button.click({ force: true });
    
    // Should only be called once
    expect(submit_handler).toHaveBeenCalledTimes(1);

    // Complete first submission
    resolve_first_submit({ success: true });
    await expect.element(submit_button).toBeEnabled();
  });

  test('should handle async file upload', async () => {
    const upload_handler = vi.fn(() => 
      Promise.resolve({ success: true, file_url: '/uploads/test.jpg' })
    );

    render(AsyncForm, { 
      onsubmit: upload_handler,
      supports_file_upload: true
    });

    // Mock file input
    const file_input = page.getByLabelText('Upload File');
    await file_input.setInputFiles([
      new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    ]);

    await page.getByRole('button', { name: 'Upload' }).click();

    // Should show upload progress
    await expect.element(page.getByText('Uploading...')).toBeInTheDocument();
    await expect.element(page.getByRole('progressbar')).toBeInTheDocument();

    // Should show success
    await expect.element(page.getByText('File uploaded successfully')).toBeInTheDocument();
    await expect.element(page.getByText('/uploads/test.jpg')).toBeInTheDocument();
  });
});
```