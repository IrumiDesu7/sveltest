```xml
<documentation>
	<core_concepts>
		<principle name="foundation_first">
			<description>
				Strategic test planning with complete test structure using describe/it.skip to comprehensively plan testing scope upfront before implementation.
			</description>
			<example>
				```typescript
				describe('TodoManager Component', () => {
					describe('Initial Rendering', () => {
						it('should render empty state', async () => {
							render(TodoManager);
							await expect.element(page.getByText('No todos yet')).toBeInTheDocument();
						});
						it.skip('should render with initial todos', async () => {
							// TODO: Test with pre-populated data
						});
					});
					describe('User Interactions', () => {
						it.skip('should add new todo', async () => {
							// TODO: Test adding functionality
						});
					});
				});
				```
			</example>
		</principle>

		<principle name="client_server_alignment">
			<description>
				Four-layer testing strategy that uses real FormData and Request objects instead of heavy mocking to catch client-server contract mismatches.
			</description>
			<layers>
				<layer name="shared_validation">Identical validation logic on client and server</layer>
				<layer name="real_objects">Real FormData/Request objects in server tests</layer>
				<layer name="typescript_contracts">Shared interfaces catch mismatches at compile time</layer>
				<layer name="e2e_safety_net">Final validation of complete integration</layer>
			</layers>
			<example>
				```typescript
				// ✅ ROBUST: Real FormData catches field name mismatches
				const form_data = new FormData();
				form_data.append('email', 'user@example.com');
				const request = new Request('http://localhost/api/register', {
					method: 'POST',
					body: form_data,
				});
				// Only mock external services, not data structures
				vi.mocked(database.create_user).mockResolvedValue({...});
				```
			</example>
		</principle>

		<principle name="locators_only">
			<description>
				Always use page locators with auto-retry built-in, never containers. Locators provide automatic waiting and semantic queries.
			</description>
			<example>
				```typescript
				// ❌ NEVER use containers - no auto-retry
				const { container } = render(MyComponent);
				const button = container.querySelector('[data-testid="submit"]');

				// ✅ ALWAYS use locators - auto-retry, semantic queries  
				render(MyComponent);
				const button = page.getByTestId('submit');
				await button.click();
				```
			</example>
		</principle>

		<principle name="semantic_queries">
			<description>
				Prefer accessibility-focused queries that test both functionality and user experience simultaneously.
			</description>
			<hierarchy>
				<level priority="1">Semantic roles (getByRole)</level>
				<level priority="2">Labels (getByLabel)</level>
				<level priority="3">Text content (getByText)</level>
				<level priority="4">Test IDs (getByTestId)</level>
			</hierarchy>
		</principle>

		<principle name="svelte5_runes">
			<description>
				Testing Svelte 5 reactive state requires untrack() for $derived values and flushSync() for synchronous updates.
			</description>
			<example>
				```typescript
				let count = $state(0);
				let doubled = $derived(count * 2);
				
				// ✅ Always use untrack() for $derived values
				expect(untrack(() => doubled)).toBe(0);
				
				count = 5;
				flushSync(); // Ensure derived state updates
				expect(untrack(() => doubled)).toBe(10);
				```
			</example>
		</principle>
	</core_concepts>

	<code_examples>
		<pattern name="basic_component_test">
			```typescript
			import { describe, expect, it, vi } from 'vitest';
			import { render } from 'vitest-browser-svelte';
			import { page } from '@vitest/browser/context';
			import MyButton from './my-button.svelte';

			describe('MyButton', () => {
				it('should render with correct text', async () => {
					render(MyButton, { children: 'Click me' });
					
					const button = page.getByRole('button', { name: 'Click me' });
					await expect.element(button).toBeInTheDocument();
				});

				it('should handle click events', async () => {
					const click_handler = vi.fn();
					render(MyButton, { onclick: click_handler });
					
					await page.getByRole('button').click();
					expect(click_handler).toHaveBeenCalledOnce();
				});
			});
			```
		</pattern>

		<pattern name="form_testing">
			```typescript
			describe('ContactForm', () => {
				it('should handle complete form submission', async () => {
					const submit_handler = vi.fn();
					render(ContactForm, { onsubmit: submit_handler });

					await page.getByLabelText('Name').fill('John Doe');
					await page.getByLabelText('Email').fill('john@example.com');
					await page.getByRole('button', { name: 'Submit' }).click();

					expect(submit_handler).toHaveBeenCalledWith({
						name: 'John Doe',
						email: 'john@example.com'
					});
				});

				it('should show validation errors', async () => {
					render(ContactForm);
					
					await page.getByRole('button', { name: 'Submit' }).click();
					await expect.element(page.getByText('Name is required')).toBeInTheDocument();
				});
			});
			```
		</pattern>

		<pattern name="strict_mode_handling">
			```typescript
			// ❌ FAILS: Multiple elements match
			page.getByRole('link', { name: 'Home' });

			// ✅ CORRECT: Handle multiple elements
			page.getByRole('link', { name: 'Home' }).first();
			page.getByRole('link', { name: 'Home' }).nth(1);
			page.getByRole('link', { name: 'Home' }).last();
			```
		</pattern>

		<pattern name="server_testing">
			```typescript
			describe('API Route', () => {
				it('should handle POST with FormData', async () => {
					const form_data = new FormData();
					form_data.append('email', 'user@example.com');
					
					const request = new Request('http://localhost/api/users', {
						method: 'POST',
						body: form_data,
					});

					vi.mocked(database.users.create).mockResolvedValue({
						id: '123',
						email: 'user@example.com',
					});

					const response = await POST({ request });
					expect(response.status).toBe(201);
				});
			});
			```
		</pattern>

		<pattern name="ssr_testing">
			```typescript
			import { render } from 'svelte/server';

			describe('Component SSR', () => {
				it('should render essential content for SEO', () => {
					const { body } = render(HomePage, {
						props: { title: 'Welcome' }
					});

					expect(body).toContain('<h1>Welcome</h1>');
					expect(body).toContain('href="/about"');
					expect(body).toContain('role="main"');
				});
			});
			```
		</pattern>

		<pattern name="vitest_config">
			```typescript
			// vite.config.ts
			export default defineConfig({
				test: {
					projects: [
						{
							// Client-side tests
							test: {
								name: 'client',
								environment: 'browser',
								browser: {
									enabled: true,
									provider: 'playwright',
									instances: [{ browser: 'chromium' }],
								},
								include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
							},
						},
						{
							// Server-side tests
							test: {
								name: 'server',
								environment: 'node',
								include: ['src/**/*.{test,spec}.{js,ts}'],
								exclude: ['src/**/*.svelte.{test,spec}.{js,ts}'],
							},
						},
					],
				},
			});
			```
		</pattern>
	</code_examples>

	<common_errors>
		<error name="strict_mode_violation">
			<symptom>"strict mode violation: getByRole() resolved to X elements"</symptom>
			<cause>Multiple elements match the locator query</cause>
			<solution>
				Use .first(), .nth(), or .last() to specify which element:
				```typescript
				// ❌ Fails with multiple elements
				page.getByRole('link', { name: 'Home' });
				
				// ✅ Specify which element
				page.getByRole('link', { name: 'Home' }).first();
				```
			</solution>
		</error>

		<error name="role_confusion">
			<symptom>Element not found with expected role</symptom>
			<cause>Incorrect role assumptions (input vs textbox, link with role="button")</cause>
			<solution>
				Check actual roles in browser DevTools:
				```typescript
				// ❌ Wrong: input elements don't have "input" role
				page.getByRole('input', { name: 'Email' });
				
				// ✅ Correct: use "textbox" for input elements
				page.getByRole('textbox', { name: 'Email' });
				
				// ❌ Wrong: link with role="button" is not a link
				page.getByRole('link', { name: 'Submit' });
				
				// ✅ Correct: use actual role attribute
				page.getByRole('button', { name: 'Submit' });
				```
			</solution>
		</error>

		<error name="derived_state_access">
			<symptom>Cannot access $derived values directly in tests</symptom>
			<cause>Svelte 5 runes require special handling in tests</cause>
			<solution>
				Always use untrack() to access $derived values:
				```typescript
				let count = $state(0);
				let doubled = $derived(count * 2);
				
				// ❌ Wrong: direct access
				expect(doubled).toBe(0);
				
				// ✅ Correct: use untrack
				expect(untrack(() => doubled)).toBe(0);
				```
			</solution>
		</error>

		<error name="form_submission_hangs">
			<symptom>Tests hang when clicking form submit buttons</symptom>
			<cause>SvelteKit form enhancement can cause SSR-related hangs</cause>
			<solution>
				Test form state directly or use force clicks:
				```typescript
				// ❌ Can hang with SvelteKit enhance
				await submit_button.click();
				
				// ✅ Test validation state instead
				render(MyForm, { errors: { email: 'Required' } });
				await expect.element(page.getByText('Required')).toBeInTheDocument();
				
				// ✅ Or use force click
				await submit_button.click({ force: true });
				```
			</solution>
		</error>

		<error name="mock_signature_mismatch">
			<symptom>"Expected 2 arguments, but got 0"</symptom>
			<cause>Mock function signature doesn't match actual function</cause>
			<solution>
				Update mock to accept correct parameters:
				```typescript
				// ❌ Wrong signature
				vi.mock('$lib/utils', () => ({
					my_function: vi.fn(),
				}));
				
				// ✅ Correct signature
				vi.mock('$lib/utils', () => ({
					my_function: vi.fn((param1: string, param2: number) => 'result'),
				}));
				```
			</solution>
		</error>

		<error name="brittle_implementation_tests">
			<symptom>Tests break after library updates despite no functional changes</symptom>
			<cause>Testing exact SVG paths or internal markup instead of user value</cause>
			<solution>
				Test semantic classes and user experience:
				```typescript
				// ❌ Brittle: exact SVG paths change with icon library updates
				expect(body).toContain('M9 12l2 2 4-4m6 2a9...');
				
				// ✅ Robust: test user-visible styling and accessibility
				await expect.element(page.getByRole('img', { name: /success/i })).toBeInTheDocument();
				await expect.element(page.getByTestId('status-icon')).toHaveClass('text-success');
				```
			</solution>
		</error>
	</common_errors>

	<references>
		<link url="https://github.com/spences10/sveltest" title="Sveltest GitHub Repository" />
		<link url="https://vitest.dev/guide/browser.html" title="Vitest Browser Mode Documentation" />
		<link url="https://github.com/vitest-dev/vitest-browser-svelte" title="vitest-browser-svelte Official Docs" />
		<link url="https://playwright.dev/docs/locators" title="Playwright Locators Reference" />
		<link url="https://svelte.dev/docs/svelte/svelte" title="Svelte 5 Runes Documentation" />
		<link url="https://scottspence.com/posts/migrating-from-testing-library-svelte-to-vitest-browser-svelte" title="Migration Guide Blog Post" />
	</references>
</documentation>
```