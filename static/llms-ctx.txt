<?xml version="1.0" encoding="UTF-8"?>
<documentation>
  <core_concepts>
    <concept id="client-server-alignment">
      <title>Client-Server Alignment Strategy</title>
      <description>A four-layer testing approach that minimizes mocking and uses real FormData/Request objects to catch client-server contract mismatches that heavily mocked tests miss.</description>
      <layers>
        <layer>Shared validation logic used by both client and server</layer>
        <layer>Real FormData/Request objects in server tests instead of mocks</layer>
        <layer>TypeScript contracts to catch mismatches at compile time</layer>
        <layer>E2E tests as final safety net for complete integration</layer>
      </layers>
    </concept>
    
    <concept id="foundation-first">
      <title>Foundation First Approach</title>
      <description>Strategic test planning using describe blocks and it.skip to create complete test structure upfront, enabling incremental implementation without forgotten edge cases.</description>
      <benefits>
        <benefit>Complete picture of requirements upfront</benefit>
        <benefit>Incremental progress by removing .skip</benefit>
        <benefit>No forgotten tests or edge cases</benefit>
        <benefit>Team alignment on testing scope</benefit>
      </benefits>
    </concept>
    
    <concept id="locator-priority">
      <title>Always Use Locators, Never Containers</title>
      <description>vitest-browser-svelte fundamental principle: use page locators with auto-retry instead of containers with manual DOM queries.</description>
      <hierarchy>
        <priority>Semantic roles (getByRole) - tests accessibility</priority>
        <priority>Labels (getByLabel) - good for forms</priority>
        <priority>Text content (getByText) - for unique text</priority>
        <priority>Test IDs (getByTestId) - fallback for complex cases</priority>
      </hierarchy>
    </concept>
    
    <concept id="svelte-5-runes">
      <title>Svelte 5 Runes Testing</title>
      <description>Testing reactive state with $state and $derived requires specific patterns including untrack() and flushSync().</description>
      <critical_rule>Always use untrack() when accessing $derived values in tests</critical_rule>
      <pattern>expect(untrack(() => derived_value)).toBe(expected)</pattern>
    </concept>
    
    <concept id="strict-mode">
      <title>Strict Mode Element Handling</title>
      <description>vitest-browser-svelte operates in strict mode - if multiple elements match a locator, you must specify which one using .first(), .nth(), or .last().</description>
      <example>page.getByRole('link', { name: 'Home' }).first()</example>
    </concept>
  </core_concepts>
  
  <code_examples>
    <example id="basic-component-test" title="Basic Component Testing Pattern">
      <![CDATA[
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import Button from './button.svelte';

describe('Button Component', () => {
  it('should render with correct variant styling', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<span>Click me</span>`
    }));
    
    render(Button, { variant: 'primary', children });

    const button = page.getByRole('button', { name: 'Click me' });
    await expect.element(button).toBeInTheDocument();
    await expect.element(button).toHaveClass('btn-primary');
  });

  it('should handle click events', async () => {
    const click_handler = vi.fn();
    const children = createRawSnippet(() => ({
      render: () => `<span>Submit</span>`
    }));
    
    render(Button, { onclick: click_handler, children });

    const button = page.getByRole('button', { name: 'Submit' });
    await button.click();

    expect(click_handler).toHaveBeenCalledOnce();
  });

  it('should support disabled state', async () => {
    const children = createRawSnippet(() => ({
      render: () => `<span>Disabled</span>`
    }));
    
    render(Button, { disabled: true, children });

    const button = page.getByRole('button', { name: 'Disabled' });
    await expect.element(button).toBeDisabled();
  });
});
      ]]>
    </example>
    
    <example id="form-validation-lifecycle" title="Form Validation Lifecycle Testing">
      <![CDATA[
import { describe, expect, it } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { flushSync, untrack } from 'svelte';
import LoginForm from './login-form.svelte';

describe('Form Validation Lifecycle', () => {
  it('should follow validation lifecycle: valid → validate → invalid → fix → valid', async () => {
    const form_state = create_form_state({
      email: { value: '', validation_rules: { required: true } }
    });

    // Initially valid (no validation triggered yet)
    expect(untrack(() => form_state.is_form_valid())).toBe(true);

    // Trigger validation with invalid data
    form_state.validate_all_fields();
    flushSync();
    expect(untrack(() => form_state.is_form_valid())).toBe(false);

    // Fix the error
    form_state.update_field('email', 'user@example.com');
    flushSync();
    expect(untrack(() => form_state.is_form_valid())).toBe(true);
  });

  it('should display validation errors in UI', async () => {
    render(LoginForm);

    const email_input = page.getByLabelText('Email');
    
    // Trigger validation by focusing and blurring
    await email_input.focus();
    await email_input.blur();

    // Error should appear
    await expect.element(page.getByText('Email is required')).toBeInTheDocument();

    // Fix the error
    await email_input.fill('valid@example.com');
    await email_input.blur();

    // Error should disappear
    await expect.element(page.getByText('Email is required')).not.toBeInTheDocument();
  });
});
      ]]>
    </example>
    
    <example id="svelte-5-runes-testing" title="Svelte 5 Runes Testing Patterns">
      <![CDATA[
// Note: This must be in a .test.svelte.ts file to use runes
import { describe, expect, it } from 'vitest';
import { flushSync, untrack } from 'svelte';

describe('Svelte 5 Runes Testing', () => {
  it('should handle $state and $derived correctly', () => {
    let count = $state(0);
    let doubled = $derived(count * 2);

    // ✅ Always use untrack() for $derived values
    expect(untrack(() => doubled)).toBe(0);

    count = 5;
    flushSync(); // Force synchronous update

    expect(untrack(() => doubled)).toBe(10);
  });

  it('should test complex derived logic', () => {
    let email = $state('');
    let submit_attempted = $state(false);
    let email_touched = $state(false);

    const email_validation = $derived(validate_email(email));
    const show_email_error = $derived(submit_attempted || email_touched);
    const email_error = $derived(
      show_email_error && !email_validation.is_valid 
        ? email_validation.error_message 
        : ''
    );

    // Initially no errors shown
    expect(untrack(() => show_email_error)).toBe(false);
    expect(untrack(() => email_error)).toBe('');

    // After touching field with invalid email
    email = 'invalid';
    email_touched = true;
    flushSync();

    expect(untrack(() => show_email_error)).toBe(true);
    expect(untrack(() => email_error)).toBe('Invalid format');
  });
});
      ]]>
    </example>
    
    <example id="client-server-alignment" title="Client-Server Alignment Testing">
      <![CDATA[
import { describe, expect, it, vi } from 'vitest';

describe('User Registration API - Client-Server Alignment', () => {
  it('should handle real FormData submission', async () => {
    // ✅ ROBUST: Real FormData catches field name mismatches
    const form_data = new FormData();
    form_data.append('email', 'user@example.com');
    form_data.append('password', 'secure123');

    // ✅ Real Request object catches header/method issues
    const request = new Request('http://localhost/api/register', {
      method: 'POST',
      body: form_data
    });

    // Only mock external services, not data structures
    vi.mocked(database.users.create).mockResolvedValue({
      id: '123',
      email: 'user@example.com'
    });

    const response = await POST({ request });
    
    expect(response.status).toBe(201);
    const data = await response.json();
    expect(data.user.email).toBe('user@example.com');
  });

  it('should validate form data consistently', async () => {
    const form_data = new FormData();
    form_data.append('email', 'invalid-email');
    
    const request = new Request('http://localhost/api/register', {
      method: 'POST',
      body: form_data
    });

    const response = await POST({ request });
    
    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.error).toContain('Invalid email format');
  });
});
      ]]>
    </example>
    
    <example id="strict-mode-handling" title="Handling Strict Mode Violations">
      <![CDATA[
import { describe, expect, it } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import Navigation from './navigation.svelte';

describe('Navigation Component - Strict Mode', () => {
  it('should handle multiple matching elements', async () => {
    render(Navigation);

    // ❌ FAILS: Strict mode violation if desktop + mobile nav both exist
    // page.getByRole('link', { name: 'Home' });

    // ✅ CORRECT: Use .first(), .nth(), .last()
    const desktop_home_link = page.getByRole('link', { name: 'Home' }).first();
    const mobile_home_link = page.getByRole('link', { name: 'Home' }).last();
    const second_link = page.getByRole('link', { name: 'Home' }).nth(1);

    await expect.element(desktop_home_link).toBeInTheDocument();
    await expect.element(mobile_home_link).toBeInTheDocument();
  });

  it('should use correct element roles', async () => {
    render(Navigation);

    // ❌ WRONG: Input role doesn't exist
    // page.getByRole('input', { name: 'Search' });

    // ✅ CORRECT: Use textbox for input elements
    const search_input = page.getByRole('textbox', { name: 'Search' });

    // ❌ WRONG: Looking for link when element has role="button"
    // page.getByRole('link', { name: 'Submit' }); // <a role="button">Submit</a>

    // ✅ CORRECT: Use the actual role attribute
    const submit_link_button = page.getByRole('button', { name: 'Submit' });

    await expect.element(search_input).toBeInTheDocument();
    await expect.element(submit_link_button).toBeInTheDocument();
  });
});
      ]]>
    </example>
    
    <example id="foundation-first-structure" title="Foundation First Test Structure">
      <![CDATA[
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import TodoManager from './todo-manager.svelte';

describe('TodoManager Component', () => {
  describe('Initial Rendering', () => {
    it('should render empty state', async () => {
      render(TodoManager);

      await expect.element(page.getByText('No todos yet')).toBeInTheDocument();
      await expect.element(page.getByRole('list')).toHaveAttribute('aria-label', 'Todo list');
    });

    it.skip('should render with initial todos', async () => {
      // TODO: Test with pre-populated data
    });
  });

  describe('User Interactions', () => {
    it('should add new todo', async () => {
      render(TodoManager);

      const input = page.getByLabelText('New todo');
      const add_button = page.getByRole('button', { name: 'Add Todo' });

      await input.fill('Buy groceries');
      await add_button.click();

      await expect.element(page.getByText('Buy groceries')).toBeInTheDocument();
    });

    it.skip('should edit existing todo', async () => {
      // TODO: Test inline editing
    });

    it.skip('should delete todo', async () => {
      // TODO: Test deletion flow
    });
  });

  describe('Form Validation', () => {
    it.skip('should prevent empty todo submission', async () => {
      // TODO: Test validation rules
    });
  });

  describe('Accessibility', () => {
    it.skip('should support keyboard navigation', async () => {
      // TODO: Test tab order and shortcuts
    });
  });

  describe('Edge Cases', () => {
    it.skip('should handle network failures gracefully', async () => {
      // TODO: Test offline scenarios
    });
  });
});
      ]]>
    </example>
    
    <example id="ssr-testing" title="SSR Testing Pattern">
      <![CDATA[
import { render } from 'svelte/server';
import { describe, expect, it } from 'vitest';
import HomePage from './+page.svelte';

describe('HomePage SSR', () => {
  it('should render without errors', () => {
    expect(() => {
      render(HomePage);
    }).not.toThrow();
  });

  it('should render essential content for SEO', () => {
    const { body, head } = render(HomePage, {
      props: {
        page_title: 'Welcome to Our Site',
        page_description: 'Best site ever'
      }
    });

    // Test core content structure
    expect(body).toContain('<h1>Welcome to Our Site</h1>');
    expect(body).toContain('Best site ever');
    expect(body).toContain('role="main"');
    expect(body).toContain('href="/about"');

    // Test meta information
    expect(head).toContain('<title>Welcome to Our Site</title>');
    expect(head).toContain('meta name="description"');
  });

  it('should render navigation structure', () => {
    const { body } = render(HomePage);

    expect(body).toContain('<nav');
    expect(body).toContain('aria-label="Main navigation"');
    expect(body).toContain('href="/docs"');
    expect(body).toContain('href="/examples"');
  });
});
      ]]>
    </example>
  </code_examples>
  
  <common_errors>
    <error id="strict-mode-violation">
      <title>Strict Mode Violation: Multiple Elements Found</title>
      <message>strict mode violation: getByRole() resolved to X elements</message>
      <cause>Multiple elements match your locator query</cause>
      <solution>Use .first(), .nth(), or .last() to specify which element</solution>
      <fix_example>
        <![CDATA[
// ❌ FAILS: Multiple nav links (desktop + mobile)
page.getByRole('link', { name: 'Home' });

// ✅ WORKS: Target specific element
page.getByRole('link', { name: 'Home' }).first();
page.getByRole('link', { name: 'Home' }).nth(1); // Second element
page.getByRole('link', { name: 'Home' }).last();
        ]]>
      </fix_example>
    </error>
    
    <error id="role-confusion">
      <title>Element Role Confusion</title>
      <message>Unable to find element by role</message>
      <cause>Using wrong role name for HTML elements</cause>
      <solution>Use correct semantic roles for different HTML elements</solution>
      <fix_example>
        <![CDATA[
// ❌ WRONG: Input role doesn't exist
page.getByRole('input', { name: 'Email' });

// ✅ CORRECT: Use textbox for input elements
page.getByRole('textbox', { name: 'Email' });

// ❌ WRONG: Looking for link when element has role="button"
page.getByRole('link', { name: 'Submit' }); // <a role="button">Submit</a>

// ✅ CORRECT: Use the actual role attribute
page.getByRole('button', { name: 'Submit' });
        ]]>
      </fix_example>
    </error>
    
    <error id="hanging-tests">
      <title>Test Hangs or Timeouts</title>
      <message>Test timeout exceeded</message>
      <cause>Usually clicking form submit buttons with SvelteKit enhance</cause>
      <solution>Test form state directly instead of clicking submits</solution>
      <fix_example>
        <![CDATA[
// ❌ Can hang with SvelteKit forms
await submit_button.click();

// ✅ Test the state directly
render(MyForm, { errors: { email: 'Required' } });
await expect.element(page.getByText('Required')).toBeInTheDocument();

// ✅ Or use force: true for animations
await submit_button.click({ force: true });
        ]]>
      </fix_example>
    </error>
    
    <error id="mock-signature-mismatch">
      <title>Mock Function Signature Mismatch</title>
      <message>Expected 2 arguments, but got 0</message>
      <cause>Mock function signature doesn't match the real function</cause>
      <solution>Update mock to accept correct number of arguments</solution>
      <fix_example>
        <![CDATA[
// ❌ Wrong signature
vi.mock('$lib/utils', () => ({
  my_function: vi.fn(),
}));

// ✅ Correct signature
vi.mock('$lib/utils', () => ({
  my_function: vi.fn((param1: string, param2: number) => 'result'),
}));
        ]]>
      </fix_example>
    </error>
    
    <error id="derived-values-without-untrack">
      <title>Testing $derived Values Without untrack()</title>
      <message>Accessing derived state outside of effect context</message>
      <cause>Trying to access $derived values directly in tests</cause>
      <solution>Always use untrack() when accessing $derived values</solution>
      <fix_example>
        <![CDATA[
// ❌ WRONG: Direct access to derived values
let count = $state(0);
let doubled = $derived(count * 2);
expect(doubled).toBe(0); // Error!

// ✅ CORRECT: Use untrack() for derived values
expect(untrack(() => doubled)).toBe(0);

count = 5;
flushSync();
expect(untrack(() => doubled)).toBe(10);
        ]]>
      </fix_example>
    </error>
    
    <error id="brittle-implementation-testing">
      <title>Brittle Tests Breaking After Library Updates</title>
      <message>Expected SVG path doesn't match after icon library update</message>
      <cause>Testing exact implementation details instead of user value</cause>
      <solution>Test semantic classes and user experience instead</solution>
      <fix_example>
        <![CDATA[
// ❌ BRITTLE: Breaks when icon library updates
expect(body).toContain('M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z');

// ✅ ROBUST: Tests user-visible behavior
await expect.element(page.getByRole('img', { name: /success/i })).toBeInTheDocument();
await expect.element(page.getByTestId('status-icon')).toHaveClass('text-success');

// ✅ Test semantic structure that survives updates
expect(body).toContain('text-success'); // Color users see
expect(body).toContain('<svg'); // Icon is present
expect(body).toContain('aria-label'); // Accessible
        ]]>
      </fix_example>
    </error>
    
    <error id="container-usage">
      <title>Using Containers Instead of Locators</title>
      <message>Container queries don't have auto-retry and fail randomly</message>
      <cause>Using render() containers for DOM queries</cause>
      <solution>Always use page locators with auto-retry</solution>
      <fix_example>
        <![CDATA[
// ❌ NEVER use containers - no auto-retry, manual DOM queries
const { container } = render(MyComponent);
const button = container.querySelector('[data-testid="submit"]');

// ✅ ALWAYS use locators - auto-retry, semantic queries
render(MyComponent);
const button = page.getByTestId('submit');
await button.click(); // Automatic waiting and retrying
        ]]>
      </fix_example>
    </error>
  </common_errors>
  
  <references>
    <reference id="official-docs">
      <title>Official vitest-browser-svelte Documentation</title>
      <url>https://github.com/vitest-dev/vitest-browser-svelte</url>
      <description>Official repository and documentation for vitest-browser-svelte</description>
    </reference>
    
    <reference id="vitest-browser">
      <title>Vitest Browser Mode Guide</title>
      <url>https://vitest.dev/guide/browser.html</url>
      <description>Official Vitest documentation for browser testing mode</description>
    </reference>
    
    <reference id="playwright-docs">
      <title>Playwright Documentation</title>
      <url>https://playwright.dev/</url>
      <description>Official Playwright documentation for browser automation</description>
    </reference>
    
    <reference id="svelte-5-docs">
      <title>Svelte 5 Documentation</title>
      <url>https://svelte.dev/docs/svelte/what-is-svelte</url>
      <description>Official Svelte 5 documentation including runes and modern patterns</description>
    </reference>
    
    <reference id="sveltest-github">
      <title>Sveltest GitHub Repository</title>
      <url>https://github.com/spences10/sveltest</url>
      <description>Complete example project demonstrating vitest-browser-svelte patterns</description>
    </reference>
    
    <reference id="migration-blog">
      <title>Migration Blog Post</title>
      <url>https://scottspence.com/posts/migrating-from-testing-library-svelte-to-vitest-browser-svelte</url>
      <description>Detailed migration story from @testing-library/svelte to vitest-browser-svelte</description>
    </reference>
    
    <reference id="sveltekit-testing">
      <title>SvelteKit Testing Documentation</title>
      <url>https://kit.svelte.dev/docs/testing</url>
      <description>Official SvelteKit testing guidance and best practices</description>
    </reference>
    
    <reference id="vite-config">
      <title>Vite Configuration Reference</title>
      <url>https://vitejs.dev/config/</url>
      <description>Complete Vite configuration options for testing setup</description>
    </reference>
  </references>
</documentation>