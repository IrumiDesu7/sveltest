<documentation>
<core_concepts>
<concept name="vitest-browser-svelte">
Modern testing solution for Svelte 5 that runs tests in real browsers instead of simulated environments. Provides native support for runes, snippets, and modern Svelte patterns with built-in auto-retry logic.
</concept>

<concept name="client-server-alignment-strategy">
Four-layer testing approach that minimizes mocking to catch real integration issues:
1. Shared validation logic between client and server
2. Real FormData/Request objects in server tests
3. TypeScript contracts for compile-time safety
4. E2E tests for complete integration validation
</concept>

<concept name="foundation-first-approach">
Strategic test planning method using describe/it.skip structure to plan comprehensive test coverage upfront, then incrementally implement tests as needed rather than arbitrary coverage metrics.
</concept>

<concept name="locators-over-containers">
Critical pattern: Always use page.getBy*() locators with automatic waiting/retrying, never containers which require manual DOM queries and have no auto-retry.
</concept>

<concept name="svelte-5-runes-testing">
Testing reactive state requires untrack() for $derived values, flushSync() for synchronous updates, and understanding that runes only work in .test.svelte.ts files.
</concept>
</core_concepts>

<code_examples>
<example name="basic-component-test">
```typescript
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';

describe('Button Component', () => {
  it('should render with correct variant', async () => {
    render(Button, { variant: 'primary', children: 'Click me' });
    
    const button = page.getByRole('button', { name: 'Click me' });
    await expect.element(button).toBeInTheDocument();
    await expect.element(button).toHaveClass('btn-primary');
  });

  it('should handle click events', async () => {
    const click_handler = vi.fn();
    render(Button, { onclick: click_handler, children: 'Click me' });
    
    await page.getByRole('button', { name: 'Click me' }).click();
    expect(click_handler).toHaveBeenCalledOnce();
  });
});
```
</example>

<example name="strict-mode-handling">
```typescript
// ❌ FAILS: Multiple elements match - strict mode violation
page.getByRole('link', { name: 'Home' });

// ✅ CORRECT: Handle multiple elements
page.getByRole('link', { name: 'Home' }).first();
page.getByRole('link', { name: 'Home' }).nth(1);
page.getByRole('link', { name: 'Home' }).last();
```
</example>

<example name="svelte-5-runes">
```typescript
import { flushSync, untrack } from 'svelte';

it('should handle $derived values', () => {
  let count = $state(0);
  let doubled = $derived(count * 2);
  
  // ✅ Always use untrack() for $derived values
  expect(untrack(() => doubled)).toBe(0);
  
  count = 5;
  flushSync(); // Ensure derived state updates
  expect(untrack(() => doubled)).toBe(10);
});
```
</example>

<example name="client-server-alignment">
```typescript
// ❌ BRITTLE: Heavy mocking hides real issues
const mock_request = { formData: vi.fn().mockResolvedValue(...) };

// ✅ ROBUST: Real FormData catches field name mismatches
const form_data = new FormData();
form_data.append('email', 'user@example.com');
const request = new Request('http://localhost/api/register', {
  method: 'POST',
  body: form_data,
});

// Only mock external services, not data structures
vi.mocked(database.users.create).mockResolvedValue({
  id: '123',
  email: 'user@example.com',
});
```
</example>

<example name="vitest-config">
```typescript
export default defineConfig({
  test: {
    projects: [
      {
        extends: './vite.config.ts',
        test: {
          name: 'client',
          environment: 'browser',
          testTimeout: 2000,
          browser: {
            enabled: true,
            provider: 'playwright',
            instances: [{ browser: 'chromium' }],
          },
          include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
          setupFiles: ['./vitest-setup-client.ts'],
        },
      },
      {
        extends: './vite.config.ts',
        test: {
          name: 'server',
          environment: 'node',
          include: ['src/**/*.{test,spec}.{js,ts}'],
          exclude: ['src/**/*.svelte.{test,spec}.{js,ts}'],
        },
      },
    ],
  },
});
```
</example>

<example name="foundation-first-structure">
```typescript
describe('TodoManager Component', () => {
  describe('Initial Rendering', () => {
    it('should render empty state', async () => {
      // Implemented test
    });
    
    it.skip('should render with initial todos', async () => {
      // TODO: Test with pre-populated data
    });
  });

  describe('User Interactions', () => {
    it.skip('should add new todo', async () => {
      // TODO: Test todo creation
    });
  });

  describe('Edge Cases', () => {
    it.skip('should handle network failures', async () => {
      // TODO: Test offline scenarios
    });
  });
});
```
</example>
</code_examples>

<common_errors>
<error name="strict-mode-violation">
**Error**: "strict mode violation: getByRole() resolved to X elements"
**Cause**: Multiple elements match the locator
**Solution**: Use .first(), .nth(), or .last() to specify which element
```typescript
// Fix: page.getByRole('link', { name: 'Home' }).first();
```
</error>

<error name="role-confusion">
**Error**: Elements not found with expected roles
**Cause**: Using wrong role names (input vs textbox, wrong role attributes)
**Solution**: Use correct semantic roles
```typescript
// ❌ page.getByRole('input', { name: 'Email' });
// ✅ page.getByRole('textbox', { name: 'Email' });
```
</error>

<error name="container-usage">
**Error**: Tests fail randomly, no auto-retry
**Cause**: Using containers instead of locators
**Solution**: Always use page.getBy*() locators
```typescript
// ❌ const { container } = render(Component);
// ✅ render(Component); const element = page.getByRole('button');
```
</error>

<error name="untrack-missing">
**Error**: "Cannot access reactive state" or derived values not working
**Cause**: Not using untrack() for $derived values
**Solution**: Always wrap $derived access in untrack()
```typescript
// ✅ expect(untrack(() => derived_value)).toBe(expected);
```
</error>

<error name="form-submission-hangs">
**Error**: Tests hang when clicking form submit buttons
**Cause**: SvelteKit form enhancement causing SSR navigation
**Solution**: Test form state directly or use force: true
```typescript
// ❌ await submit_button.click();
// ✅ await submit_button.click({ force: true });
// ✅ Or test validation state directly
```
</error>

<error name="mock-signature-mismatch">
**Error**: "Expected 2 arguments, but got 0"
**Cause**: Mock function signature doesn't match real function
**Solution**: Update mock to accept correct parameters
```typescript
// ✅ vi.fn((param1: string, param2: number) => 'result')
```
</error>
</common_errors>
</documentation>