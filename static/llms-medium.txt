# Sveltest Testing Documentation

> Comprehensive vitest-browser-svelte testing patterns for modern Svelte 5 applications. Real-world examples demonstrating client-server alignment, component testing in actual browsers, SSR validation, and migration from @testing-library/svelte.

## Getting Started

### Learn Modern Svelte Testing

This guide demonstrates testing Svelte 5 applications using the experimental `vitest-browser-svelte` - the modern testing solution that runs tests in real browsers instead of simulated environments.

**You'll learn:**
- Essential testing patterns that work in real browsers
- Best practices for testing Svelte 5 components with runes
- How to avoid common pitfalls and write reliable tests
- The **Client-Server Alignment Strategy** for reliable full-stack testing

### Setup Your Own Project

Create a new SvelteKit project with browser testing:

```bash
# Create project
pnpm dlx sv@latest create my-testing-app

# Install browser testing dependencies
cd my-testing-app
pnpm install -D @vitest/browser vitest-browser-svelte playwright

# Remove old dependencies
pnpm un @testing-library/jest-dom @testing-library/svelte jsdom
```

### Configure Vitest Browser Mode

Update `vite.config.ts` for multi-project browser testing:

```typescript
import { defineConfig } from 'vite';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		projects: [
			{
				// Client-side tests (Svelte components)
				test: {
					name: 'client',
					environment: 'browser',
					testTimeout: 2000,
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [{ browser: 'chromium' }],
					},
					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					setupFiles: ['./vitest-setup-client.ts'],
				},
			},
			{
				// SSR tests
				test: {
					name: 'ssr',
					environment: 'node',
					include: ['src/**/*.ssr.{test,spec}.{js,ts}'],
				},
			},
			{
				// Server-side tests
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.svelte.{test,spec}.{js,ts}'],
				},
			},
		],
	},
});
```

### Setup File

Create `vitest-setup-client.ts`:

```typescript
/// <reference types="@vitest/browser/matchers" />
/// <reference types="@vitest/browser/providers/playwright" />
```

### Write Your First Test

Create `src/lib/components/my-button.svelte`:

```svelte
<script lang="ts">
	interface Props {
		variant?: 'primary' | 'secondary';
		disabled?: boolean;
		onclick?: () => void;
		children: any;
	}

	let { variant = 'primary', disabled = false, onclick, children }: Props = $props();
</script>

<button class="btn btn-{variant}" {disabled} {onclick}>
	{@render children()}
</button>
```

Create `src/lib/components/my-button.svelte.test.ts`:

```typescript
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import MyButton from './my-button.svelte';

describe('MyButton', () => {
	it('should render with correct text', async () => {
		const children = createRawSnippet(() => ({
			render: () => `<span>Click me</span>`,
		}));

		render(MyButton, { children });

		const button = page.getByRole('button', { name: 'Click me' });
		await expect.element(button).toBeInTheDocument();
	});

	it('should handle click events', async () => {
		const click_handler = vi.fn();
		const children = createRawSnippet(() => ({
			render: () => `<span>Click me</span>`,
		}));

		render(MyButton, { onclick: click_handler, children });

		const button = page.getByRole('button', { name: 'Click me' });
		await button.click();

		expect(click_handler).toHaveBeenCalledOnce();
	});
});
```

## Testing Patterns

### Essential Setup Pattern

```typescript
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import { flushSync, untrack } from 'svelte';
```

### Locator Patterns - Always Use Locators

**CRITICAL**: Always use locators, never containers. Locators have automatic waiting and retrying.

```typescript
// ✅ DO: Use page locators (auto-retry, semantic)
const button = page.getByRole('button', { name: 'Submit' });
await button.click();

// ❌ DON'T: Use containers (no auto-retry, manual queries)
const { container } = render(MyButton);
const button = container.querySelector('button');
```

### Handling Multiple Elements (Strict Mode)

vitest-browser-svelte operates in strict mode - if multiple elements match, you must specify which one:

```typescript
// ❌ FAILS: Strict mode violation if multiple elements match
page.getByRole('link', { name: 'Home' });

// ✅ CORRECT: Use .first(), .nth(), .last()
page.getByRole('link', { name: 'Home' }).first();
page.getByRole('link', { name: 'Home' }).nth(1);
page.getByRole('link', { name: 'Home' }).last();
```

### Component Testing Patterns

#### Button Component

```typescript
describe('Button Component', () => {
	it('should render with variant styling', async () => {
		render(Button, { variant: 'primary', children: 'Click me' });

		const button = page.getByRole('button', { name: 'Click me' });
		await expect.element(button).toHaveClass('btn-primary');
	});

	it('should handle disabled state', async () => {
		render(Button, { disabled: true, children: 'Disabled' });

		const button = page.getByRole('button', { name: 'Disabled' });
		await expect.element(button).toBeDisabled();
	});
});
```

#### Form Component

```typescript
it('should handle form validation lifecycle', async () => {
	render(LoginForm);

	const email_input = page.getByLabelText('Email');
	const submit_button = page.getByRole('button', { name: 'Submit' });

	// Initially valid (no validation triggered)
	await expect.element(submit_button).toBeEnabled();

	// Trigger validation with invalid data
	await email_input.fill('invalid-email');
	await submit_button.click({ force: true });

	// Now invalid with error message
	await expect.element(page.getByText('Invalid email format')).toBeVisible();
});
```

### Svelte 5 Runes Testing

```typescript
describe('Reactive State', () => {
	it('should handle $state and $derived correctly', () => {
		let count = $state(0);
		let doubled = $derived(count * 2);

		// ✅ Always use untrack() for $derived values
		expect(untrack(() => doubled)).toBe(0);

		count = 5;
		flushSync(); // Ensure derived state updates
		expect(untrack(() => doubled)).toBe(10);
	});
});
```

## Form Testing

### Form Submission Pattern

```typescript
it('should handle complete form submission flow', async () => {
	const submit_handler = vi.fn();
	render(ContactForm, { onsubmit: submit_handler });

	// Fill out form
	await page.getByLabelText('Name').fill('John Doe');
	await page.getByLabelText('Email').fill('john@example.com');
	await page.getByLabelText('Message').fill('Hello world');

	// Submit form
	await page.getByRole('button', { name: 'Send Message' }).click();

	// Verify submission
	expect(submit_handler).toHaveBeenCalledWith({
		name: 'John Doe',
		email: 'john@example.com',
		message: 'Hello world',
	});
});
```

### Avoid SvelteKit Form Submit Hangs

```typescript
// ❌ Can cause hangs with SvelteKit enhance
await submit_button.click();

// ✅ Test form state directly
render(MyForm, { errors: { email: 'Required' } });
await expect.element(page.getByText('Required')).toBeInTheDocument();
```

## SSR Testing

### Basic SSR Pattern

```typescript
import { render } from 'svelte/server';

describe('Component SSR', () => {
	it('should render without errors', () => {
		expect(() => {
			render(ComponentName);
		}).not.toThrow();
	});

	it('should render essential content for SEO', () => {
		const { body } = render(ComponentName, {
			props: { title: 'Page Title' },
		});

		expect(body).toContain('<h1>Page Title</h1>');
		expect(body).toContain('href="/important-link"');
	});
});
```

## Mocking Patterns

### Utility Function Mocking

```typescript
// Mock utility functions with realistic return values
vi.mock('$lib/utils/api', () => ({
	fetch_user_data: vi.fn(() =>
		Promise.resolve({
			id: 1,
			name: 'John Doe',
			email: 'john@example.com',
		}),
	),
	validate_email: vi.fn((email: string) => email.includes('@')),
}));
```

### Component Mocking (Only When Necessary)

```typescript
// Mock heavy external components
vi.mock('@external/heavy-chart', () => ({
	default: vi.fn(() => ({
		$$: {},
		$set: vi.fn(),
		$destroy: vi.fn(),
	})),
}));
```

## Error Handling

### Async Error Testing

```typescript
it('should handle loading states', async () => {
	render(AsyncDataComponent);

	// Should show loading initially
	await expect.element(page.getByText('Loading...')).toBeInTheDocument();

	// Wait for data to load
	await expect.element(page.getByText('Data loaded')).toBeInTheDocument();
});
```

## Client-Server Alignment Strategy

### The Problem with Heavy Mocking

Server tests with heavy mocking can pass while production fails due to client-server mismatches.

```typescript
// ❌ BRITTLE: Heavy mocking hides client-server mismatches
const mock_request = {
	formData: vi.fn().mockResolvedValue({
		get: vi.fn().mockReturnValue('test@example.com'),
	}),
};

// ✅ ROBUST: Real FormData catches actual mismatches
const form_data = new FormData();
form_data.append('email', 'test@example.com');
const request = new Request('http://localhost/register', {
	method: 'POST',
	body: form_data,
});
```

### What to Mock vs Keep Real

#### ✅ Mock External Dependencies

```typescript
// Database operations
vi.mock('$lib/database', () => ({
	users: { create: vi.fn(), find_by_email: vi.fn() },
}));

// External APIs
vi.mock('$lib/email-service', () => ({
	send_welcome_email: vi.fn(),
}));
```

#### ❌ Keep Data Contracts Real

```typescript
// ✅ Real FormData objects
const form_data = new FormData();
form_data.append('email', 'test@example.com');

// ✅ Real Request/Response objects
const request = new Request('http://localhost/api/users', {
	method: 'POST',
	body: form_data,
});
```

## Common Issues & Solutions

### "strict mode violation: getByRole() resolved to X elements"

Most common issue. Multiple elements match your locator:

```typescript
// ❌ FAILS: Multiple nav links (desktop + mobile)
page.getByRole('link', { name: 'Home' });

// ✅ WORKS: Target specific element
page.getByRole('link', { name: 'Home' }).first();
```

### Role Confusion

```typescript
// ❌ WRONG: Input role doesn't exist
page.getByRole('input', { name: 'Email' });

// ✅ CORRECT: Use textbox for input elements
page.getByRole('textbox', { name: 'Email' });
```

### Mock Function Signature Errors

```typescript
// ❌ Wrong signature
vi.mock('$lib/utils', () => ({
	my_function: vi.fn(),
}));

// ✅ Correct signature
vi.mock('$lib/utils', () => ({
	my_function: vi.fn((param1: string, param2: number) => 'result'),
}));
```

## Quick Reference

### Essential Patterns

- ✅ Use `page.getBy*()` locators - never containers
- ✅ Always `await expect.element()` for assertions
- ✅ Use `.first()`, `.nth()`, `.last()` for multiple elements
- ✅ Use `untrack()` for `$derived` values
- ✅ Use `force: true` for animations: `await element.click({ force: true })`
- ✅ Test form validation lifecycle: initial (valid) → validate → fix
- ✅ Handle strict mode violations properly

### Common Fixes

- **"strict mode violation"**: Use `.first()`, `.nth()`, `.last()`
- **Role confusion**: Links with `role="button"` are buttons
- **Input elements**: Use `getByRole('textbox')`, not `getByRole('input')`
- **Form hangs**: Don't click SvelteKit form submits - test state directly
- **Animation issues**: Use `force: true` for click events

### Anti-Patterns to Avoid

- ❌ Never use containers: `const { container } = render()`
- ❌ Don't ignore strict mode violations
- ❌ Don't test SVG paths or implementation details
- ❌ Don't expect forms to be invalid initially
- ❌ Don't click SvelteKit form submits in tests