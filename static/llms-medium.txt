# Sveltest Testing Documentation

> Comprehensive vitest-browser-svelte testing patterns for modern Svelte 5 applications. Real-world examples demonstrating client-server alignment, component testing in actual browsers, SSR validation, and migration from @testing-library/svelte.

## Getting Started

### Learn Modern Svelte Testing

This guide demonstrates testing Svelte 5 applications using the experimental `vitest-browser-svelte` - the modern testing solution that runs your tests in real browsers instead of simulated environments.

**You'll learn:**
- Essential testing patterns that work in real browsers
- Best practices for testing Svelte 5 components with runes
- How to avoid common pitfalls and write reliable tests
- The **Client-Server Alignment Strategy** for reliable full-stack testing

### What is Sveltest?

Sveltest is a **reference guide and example project** that demonstrates real-world testing patterns with `vitest-browser-svelte`. You don't install Sveltest - you learn from it and apply these patterns to your own Svelte applications.

### Setup Your Own Project

Create a new SvelteKit project with `sv` CLI:

```bash
# Create a new SvelteKit project with sv
pnpm dlx sv@latest create my-testing-app
```

### Install Browser Testing Dependencies

```bash
cd my-testing-app
# Add vitest browser, Svelte testing and playwright
pnpm install -D @vitest/browser vitest-browser-svelte playwright

# remove testing library and jsdom
pnpm un @testing-library/jest-dom @testing-library/svelte jsdom
```

### Configure Vitest Browser Mode

Update your `vite.config.ts` to use the official Vitest Browser configuration:

```typescript
import tailwindcss from '@tailwindcss/vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [tailwindcss(), sveltekit()],

	test: {
		projects: [
			{
				// Client-side tests (Svelte components)
				extends: './vite.config.ts',
				test: {
					name: 'client',
					environment: 'browser',
					testTimeout: 2000,
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [
							{ browser: 'chromium' },
						],
					},
					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					exclude: [
						'src/lib/server/**',
						'src/**/*.ssr.{test,spec}.{js,ts}',
					],
					setupFiles: ['./src/vitest-setup-client.ts'],
				},
			},
			{
				// SSR tests (Server-side rendering)
				extends: './vite.config.ts',
				test: {
					name: 'ssr',
					environment: 'node',
					include: ['src/**/*.ssr.{test,spec}.{js,ts}'],
				},
			},
			{
				// Server-side tests (Node.js utilities)
				extends: './vite.config.ts',
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: [
						'src/**/*.svelte.{test,spec}.{js,ts}',
						'src/**/*.ssr.{test,spec}.{js,ts}',
					],
				},
			},
		],
	},
});
```

### Edit Setup File

Replace the contents of the `vitest-setup-client.ts` with this:

```typescript
/// <reference types="@vitest/browser/matchers" />
/// <reference types="@vitest/browser/providers/playwright" />
```

### Run the tests

Replace the contents of `page.svelte.test.ts` with this:

```ts
import { page } from '@vitest/browser/context';
import { describe, expect, it } from 'vitest';
import { render } from 'vitest-browser-svelte';
import Page from './+page.svelte';

describe('/+page.svelte', () => {
	it('should render h1', async () => {
		render(Page);

		const heading = page.getByRole('heading', { level: 1 });
		await expect.element(heading).toBeInTheDocument();
	});
});
```

## Understanding the Client-Server Alignment Strategy

The **Client-Server Alignment Strategy** guides this testing approach:

### The Four-Layer Approach

1. **Shared Validation Logic**: Use the same validation functions on both client and server
2. **Real FormData/Request Objects**: Server tests use real web APIs, not mocks
3. **TypeScript Contracts**: Shared interfaces catch mismatches at compile time
4. **E2E Tests**: Final safety net for complete integration validation

### Why This Matters

Traditional testing with heavy mocking can pass while production fails due to client-server mismatches:

```typescript
// ❌ BRITTLE: Heavy mocking hides real issues
const mock_request = { formData: vi.fn().mockResolvedValue(...) };

// ✅ ROBUST: Real FormData catches field name mismatches
const form_data = new FormData();
form_data.append('email', 'user@example.com');
const request = new Request('http://localhost/api/register', {
	method: 'POST',
	body: form_data,
});
```

## Write Your First Test

Create `src/lib/components/my-button.svelte`:

```svelte
<script lang="ts">
	interface Props {
		variant?: 'primary' | 'secondary';
		disabled?: boolean;
		onclick?: () => void;
		children: any;
	}

	let {
		variant = 'primary',
		disabled = false,
		onclick,
		children,
	}: Props = $props();
</script>

<button
	class="btn btn-{variant}"
	{disabled}
	{onclick}
	data-testid="my-button"
>
	{@render children()}
</button>
```

Create `src/lib/components/my-button.svelte.test.ts`:

```typescript
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
import { createRawSnippet } from 'svelte';
import MyButton from './my-button.svelte';

describe('MyButton', () => {
	it('should render with correct text', async () => {
		const children = createRawSnippet(() => ({
			render: () => `<span>Click me</span>`,
		}));

		render(MyButton, { children });

		const button = page.getByRole('button', { name: 'Click me' });
		await expect.element(button).toBeInTheDocument();
	});

	it('should handle click events', async () => {
		const click_handler = vi.fn();
		const children = createRawSnippet(() => ({
			render: () => `<span>Click me</span>`,
		}));

		render(MyButton, { onclick: click_handler, children });

		const button = page.getByRole('button', { name: 'Click me' });
		await button.click();

		expect(click_handler).toHaveBeenCalledOnce();
	});
});
```

## Essential Patterns

### Always Use Locators

**NEVER** use containers - they don't have auto-retry and require manual DOM queries:

```typescript
// ❌ NEVER use containers - no auto-retry, manual DOM queries
const { container } = render(MyComponent);
const button = container.querySelector('[data-testid="submit"]');

// ✅ ALWAYS use locators - auto-retry, semantic queries
render(MyComponent);
const button = page.getByTestId('submit');
await button.click(); // Automatic waiting and retrying
```

### Locator Hierarchy (Use in This Order)

1. **Semantic roles** (best for accessibility):
   ```typescript
   page.getByRole('button', { name: 'Submit' });
   page.getByRole('textbox', { name: 'Email' });
   ```

2. **Labels** (good for forms):
   ```typescript
   page.getByLabel('Email address');
   ```

3. **Text content** (good for unique text):
   ```typescript
   page.getByText('Welcome back');
   ```

4. **Test IDs** (fallback for complex cases):
   ```typescript
   page.getByTestId('submit-button');
   ```

### Handle Multiple Elements (Strict Mode)

Vitest Browser operates in **strict mode** - if multiple elements match, you'll get an error:

```typescript
// ❌ FAILS: "strict mode violation" if multiple elements match
page.getByRole('link', { name: 'Home' });

// ✅ CORRECT: Use .first(), .nth(), .last() for multiple elements
page.getByRole('link', { name: 'Home' }).first();
page.getByRole('link', { name: 'Home' }).nth(1); // Second element (0-indexed)
page.getByRole('link', { name: 'Home' }).last();
```

## Testing Patterns

### Component Testing Patterns

```typescript
describe('Button Component', () => {
	it('should render with variant styling', async () => {
		render(Button, { variant: 'primary', children: 'Click me' });

		const button = page.getByRole('button', { name: 'Click me' });
		await expect.element(button).toBeInTheDocument();
		await expect.element(button).toHaveClass('btn-primary');
	});

	it('should handle click events', async () => {
		const click_handler = vi.fn();
		render(Button, { onclick: click_handler, children: 'Click me' });

		const button = page.getByRole('button', { name: 'Click me' });
		await button.click();

		expect(click_handler).toHaveBeenCalledOnce();
	});

	it('should support disabled state', async () => {
		render(Button, { disabled: true, children: 'Disabled' });

		const button = page.getByRole('button', { name: 'Disabled' });
		await expect.element(button).toBeDisabled();
	});
});
```

### Form Testing Pattern

```typescript
describe('Input Component', () => {
	it('should handle user input', async () => {
		render(Input, { type: 'text', label: 'Full Name' });

		const input = page.getByLabelText('Full Name');
		await input.fill('John Doe');

		await expect.element(input).toHaveValue('John Doe');
	});

	it('should display validation errors', async () => {
		render(Input, {
			type: 'email',
			label: 'Email',
			error: 'Invalid email format',
		});

		const error_message = page.getByText('Invalid email format');

		await expect.element(error_message).toBeInTheDocument();
	});
});
```

### Svelte 5 Runes Testing

```typescript
import { untrack, flushSync } from 'svelte';

it('should handle reactive state', () => {
	let count = $state(0);
	let doubled = $derived(count * 2);

	expect(untrack(() => doubled)).toBe(0);

	count = 5;
	flushSync(); // Ensure derived state updates
	expect(untrack(() => doubled)).toBe(10);
});
```

### SSR Testing Pattern

```typescript
import { render } from 'svelte/server';

describe('Component SSR', () => {
	it('should render without errors', () => {
		expect(() => {
			render(ComponentName);
		}).not.toThrow();
	});

	it('should render essential content for SEO', () => {
		const { body } = render(ComponentName, {
			props: { title: 'Page Title', description: 'Page description' },
		});

		expect(body).toContain('<h1>Page Title</h1>');
		expect(body).toContain('Page description');
		expect(body).toContain('href="/important-link"');
	});
});
```

### Server Testing Pattern (Client-Server Alignment)

```typescript
describe('API Route', () => {
	it('should handle POST requests with validation', async () => {
		// ✅ Real Request with FormData - tests actual parsing
		const form_data = new FormData();
		form_data.append('email', 'user@example.com');
		form_data.append('password', 'secure123');

		const request = new Request('http://localhost/api/register', {
			method: 'POST',
			body: form_data,
		});

		// Only mock external services, not data structures
		vi.mocked(database.users.create).mockResolvedValue({
			id: '123',
			email: 'user@example.com',
		});

		const response = await POST({ request });
		expect(response.status).toBe(201);

		const data = await response.json();
		expect(data.user.email).toBe('user@example.com');
	});
});
```

## Best Practices

### Foundation First Approach

Start with complete test structure using `describe` and `it.skip`:

```typescript
describe('TodoManager Component', () => {
	describe('Initial Rendering', () => {
		it('should render empty state', async () => {
			// Implementation
		});

		it.skip('should render with initial todos', async () => {
			// TODO: Test with pre-populated data
		});
	});

	describe('User Interactions', () => {
		it.skip('should add new todo', async () => {
			// TODO: Test adding functionality
		});
	});

	describe('Edge Cases', () => {
		it.skip('should handle network failures gracefully', async () => {
			// TODO: Test offline scenarios
		});
	});
});
```

### Avoid Testing Implementation Details

```typescript
// ❌ BRITTLE ANTI-PATTERN - Tests exact SVG path data
expect(body).toContain(
	'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
);

// ✅ ROBUST PATTERN - Tests semantic meaning and user experience
await expect
	.element(page.getByRole('img', { name: /success/i }))
	.toBeInTheDocument();
await expect
	.element(page.getByTestId('status-icon'))
	.toHaveClass('text-success');
```

## Common Pitfalls & Solutions

### "strict mode violation: getByRole() resolved to X elements"

**Most common issue** with Vitest Browser Mode. Multiple elements match your locator:

```typescript
// ❌ FAILS: Multiple nav links (desktop + mobile)
page.getByRole('link', { name: 'Home' });

// ✅ WORKS: Target specific element
page.getByRole('link', { name: 'Home' }).first();
```

### Role and Element Confusion

```typescript
// ❌ WRONG: Input role doesn't exist
page.getByRole('input', { name: 'Email' });

// ✅ CORRECT: Use textbox for input elements
page.getByRole('textbox', { name: 'Email' });

// ❌ WRONG: Looking for link when element has role="button"
page.getByRole('link', { name: 'Submit' }); // <a role="button">Submit</a>

// ✅ CORRECT: Use the actual role attribute
page.getByRole('button', { name: 'Submit' });
```

### Test Hangs

Usually caused by clicking form submit buttons with SvelteKit enhance:

```typescript
// ❌ Can hang with SvelteKit forms
await submit_button.click();

// ✅ Test the state directly
render(MyForm, { errors: { email: 'Required' } });
await expect.element(page.getByText('Required')).toBeInTheDocument();
```

### Form Validation Lifecycle

```typescript
// ✅ CORRECT: Forms typically start valid (not validated yet)
expect(untrack(() => form_state.is_form_valid())).toBe(true);

// Trigger validation - now should be invalid
form_state.validate_all_fields();
flushSync();
expect(untrack(() => form_state.is_form_valid())).toBe(false);

// Fix the field - should become valid again
form_state.update_field('email', 'valid@example.com');
flushSync();
expect(untrack(() => form_state.is_form_valid())).toBe(true);
```

## Migration from @testing-library/svelte

### Essential Import Changes

```typescript
// BEFORE: @testing-library/svelte
import { render, screen } from '@testing-library/svelte';
import userEvent from '@testing-library/user-event';

// AFTER: vitest-browser-svelte
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
```

### Query Transformations

| @testing-library/svelte          | vitest-browser-svelte          |
| -------------------------------- | ------------------------------ |
| `screen.getByRole('button')`     | `page.getByRole('button')`     |
| `screen.getByText('Hello')`      | `page.getByText('Hello')`      |
| `screen.getByTestId('submit')`   | `page.getByTestId('submit')`   |

### Assertion Transformations

| @testing-library/svelte                   | vitest-browser-svelte                                   |
| ----------------------------------------- | ------------------------------------------------------- |
| `expect(element).toBeInTheDocument()`     | `await expect.element(element).toBeInTheDocument()`     |
| `expect(element).toHaveClass('btn')`      | `await expect.element(element).toHaveClass('btn')`      |

### Event Handling Transformations

| @testing-library/svelte                                        | vitest-browser-svelte                 |
| -------------------------------------------------------------- | ------------------------------------- |
| `await fireEvent.click(button)`                                | `await button.click()`                |
| `await fireEvent.change(input, { target: { value: 'test' } })` | `await input.fill('test')`            |

## API Reference

### Essential Setup

```typescript
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
```

### Locators (Auto-Retry Built-in)

```typescript
// Semantic queries (preferred)
page.getByRole('button', { name: 'Submit' });
page.getByRole('textbox', { name: 'Email' });

// Form-specific queries
page.getByLabel('Email address');
page.getByPlaceholder('Enter your email');

// Content queries
page.getByText('Welcome back');

// Test ID fallback
page.getByTestId('submit-button');
```

### Assertions (Always Await)

```typescript
// Element presence
await expect.element(page.getByText('Success')).toBeInTheDocument();
await expect.element(page.getByRole('button')).toBeVisible();

// Element states
await expect.element(page.getByRole('button')).toBeEnabled();
await expect.element(page.getByRole('checkbox')).toBeChecked();

// Content & attributes
await expect.element(page.getByRole('heading')).toHaveText('Welcome');
await expect.element(page.getByRole('textbox')).toHaveValue('john@example.com');
await expect.element(page.getByRole('link')).toHaveAttribute('href', '/docs');
```

### User Interactions

```typescript
// Click events
await page.getByRole('button').click();
await page.getByRole('button').click({ force: true }); // Force click for animations

// Form interactions
await page.getByRole('textbox').fill('john@example.com');
await page.getByRole('checkbox').check();
await page.getByRole('combobox').selectOption('value');

// Keyboard interactions
await page.keyboard.press('Enter');
await page.keyboard.type('Hello World');
```

## Quick Reference Checklist

### Essential Patterns ✅

- Use `page.getBy*()` locators - never containers
- Always await locator assertions: `await expect.element()`
- Use `.first()`, `.nth()`, `.last()` for multiple elements
- Use `untrack()` for Svelte 5 `$derived` values: `expect(untrack(() => derived_value))`
- Use `force: true` for animations: `await element.click({ force: true })`
- Test form validation lifecycle: initial (valid) → validate → fix
- Use snake_case for variables/functions, kebab-case for files
- Handle role confusion: `textbox` not `input`, check actual `role` attributes

### Common Fixes

- **"strict mode violation"**: Use `.first()`, `.nth()`, `.last()`
- **Role confusion**: Links with `role="button"` are buttons, use `getByRole('button')`
- **Input elements**: Use `getByRole('textbox')`, not `getByRole('input')`
- **Form hangs**: Don't click SvelteKit form submits - test state directly
- **Animation issues**: Use `force: true` for click events

### Anti-Patterns to Avoid ❌

- Never use containers: `const { container } = render()`
- Don't ignore strict mode violations
- Don't assume element roles - verify with browser dev tools
- Don't expect forms to be invalid initially
- Don't click SvelteKit form submits in tests
- Don't test SVG paths or internal markup

---

This documentation supports the **Client-Server Alignment Strategy** by providing testing patterns that work reliably across client and server environments, ensuring your tests catch real integration issues before they reach production.
