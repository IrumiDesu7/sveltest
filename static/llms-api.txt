# Sveltest API Reference

## Essential Imports and Setup

### Core Dependencies
```typescript
import { describe, expect, it, vi } from 'vitest';
import { render } from 'vitest-browser-svelte';
import { page } from '@vitest/browser/context';
```

### Svelte 5 Runes and SSR
```typescript
import { createRawSnippet } from 'svelte';
import { flushSync, untrack } from 'svelte';
import { render } from 'svelte/server'; // SSR testing only
```

### Real Web APIs for Server Testing
```typescript
const form_data = new FormData();
const request = new Request('http://localhost/api/endpoint', {
  method: 'POST',
  body: form_data,
});
```

## Locator Methods and Queries

### Semantic Queries (Preferred)
```typescript
// Button elements with accessibility testing
page.getByRole(
  role: 'button',
  options?: { name?: string | RegExp; exact?: boolean }
): Locator

// Form control elements
page.getByRole(
  role: 'textbox' | 'checkbox' | 'combobox' | 'radio',
  options?: { name?: string | RegExp }
): Locator

// Navigation and structural elements
page.getByRole(
  role: 'link' | 'heading' | 'main' | 'navigation' | 'dialog',
  options?: { name?: string | RegExp; level?: number }
): Locator

// Usage examples
page.getByRole('button', { name: 'Submit' });
page.getByRole('textbox', { name: 'Email' });
page.getByRole('heading', { level: 1 });
page.getByRole('link', { name: /documentation/i });
```

### Form-Specific Queries
```typescript
// Label-based queries (best for forms)
page.getByLabel(
  text: string | RegExp,
  options?: { exact?: boolean }
): Locator

// Placeholder-based queries
page.getByPlaceholder(
  text: string | RegExp,
  options?: { exact?: boolean }
): Locator

// Usage examples
page.getByLabel('Email address');
page.getByPlaceholder('Enter your email');
page.getByPlaceholder(/search/i);
```

### Content and Test ID Queries
```typescript
// Text content queries
page.getByText(
  text: string | RegExp,
  options?: { exact?: boolean }
): Locator

// Test ID fallback (when semantic queries aren't possible)
page.getByTestId(testId: string): Locator

// Usage examples
page.getByText('Welcome back');
page.getByText('Welcome', { exact: false });
page.getByTestId('submit-button');
```

### Multiple Element Handling (Strict Mode)
```typescript
// Handle multiple matching elements
page.getByRole('link', { name: 'Home' }).first(): Locator
page.getByRole('listitem').nth(index: number): Locator
page.getByRole('button').last(): Locator

// Filter for specificity
page.getByRole('button').filter(options: {
  hasText?: string | RegExp;
  has?: Locator;
}): Locator

// Chain for context
page.getByRole('dialog').getByRole('button', { name: 'Close' }): Locator

// Usage examples
page.getByRole('link', { name: 'Home' }).first();
page.getByRole('listitem').nth(2); // Zero-indexed
page.getByRole('button').filter({ hasText: 'Delete' });
```

## Assertion Patterns with Type Definitions

### Element Presence Assertions
```typescript
// Always await element assertions
await expect.element(locator: Locator).toBeInTheDocument(): Promise<void>
await expect.element(locator: Locator).toBeVisible(): Promise<void>
await expect.element(locator: Locator).toBeHidden(): Promise<void>
await expect.element(locator: Locator).toBeAttached(): Promise<void>

// Negation patterns
await expect.element(locator: Locator).not.toBeInTheDocument(): Promise<void>
```

### Element State Assertions
```typescript
// Interactive states
await expect.element(locator: Locator).toBeEnabled(): Promise<void>
await expect.element(locator: Locator).toBeDisabled(): Promise<void>
await expect.element(locator: Locator).toBeChecked(): Promise<void>
await expect.element(locator: Locator).toBeFocused(): Promise<void>

// Content and attributes
await expect.element(locator: Locator).toHaveText(
  expected: string | RegExp
): Promise<void>

await expect.element(locator: Locator).toContainText(
  expected: string | RegExp
): Promise<void>

await expect.element(locator: Locator).toHaveValue(
  value: string | RegExp
): Promise<void>

await expect.element(locator: Locator).toHaveAttribute(
  name: string,
  value?: string | RegExp
): Promise<void>

await expect.element(locator: Locator).toHaveClass(
  className: string | RegExp | string[]
): Promise<void>
```

### Count Assertions
```typescript
// Exact and range counts
await expect.element(locator: Locator).toHaveCount(
  count: number | { min?: number; max?: number }
): Promise<void>

// Usage examples
await expect.element(page.getByRole('listitem')).toHaveCount(3);
await expect.element(page.getByRole('button')).toHaveCount({ min: 1 });
await expect.element(page.getByRole('button')).toHaveCount({ max: 5 });
```

## User Interaction Methods

### Click Events
```typescript
// Basic click with options
locator.click(options?: {
  button?: 'left' | 'right' | 'middle';
  clickCount?: number;
  force?: boolean;
  position?: { x: number; y: number };
  timeout?: number;
}): Promise<void>

// Usage examples
await page.getByRole('button', { name: 'Submit' }).click();
await page.getByRole('button').click({ force: true }); // Bypass animations
await page.getByRole('button').click({
  button: 'right',
  clickCount: 2,
  position: { x: 10, y: 20 }
});
```

### Form Interactions
```typescript
// Text input methods
locator.fill(value: string, options?: { timeout?: number }): Promise<void>
locator.clear(options?: { timeout?: number }): Promise<void>

// Selection methods
locator.check(options?: { force?: boolean; timeout?: number }): Promise<void>
locator.uncheck(options?: { force?: boolean; timeout?: number }): Promise<void>
locator.selectOption(
  values: string | string[] | { value?: string; label?: string; index?: number },
  options?: { timeout?: number }
): Promise<string[]>

// File upload
locator.setInputFiles(
  files: string | string[] | FilePayload | FilePayload[],
  options?: { timeout?: number }
): Promise<void>

// Usage examples
await page.getByRole('textbox', { name: 'Email' }).fill('john@example.com');
await page.getByRole('textbox').clear();
await page.getByRole('checkbox').check();
await page.getByRole('combobox').selectOption('value');
await page.getByRole('textbox', { name: 'Upload' }).setInputFiles('path/to/file.txt');
```

### Keyboard Interactions
```typescript
// Global keyboard methods
page.keyboard.press(key: string, options?: { delay?: number }): Promise<void>
page.keyboard.type(text: string, options?: { delay?: number }): Promise<void>

// Element-specific keyboard
locator.press(key: string, options?: { delay?: number; timeout?: number }): Promise<void>

// Usage examples
await page.keyboard.press('Enter');
await page.keyboard.press('Control+A');
await page.keyboard.type('Hello World');
await page.getByRole('textbox').press('Enter');
```

### Focus and Hover
```typescript
locator.focus(options?: { timeout?: number }): Promise<void>
locator.blur(options?: { timeout?: number }): Promise<void>
locator.hover(options?: { 
  position?: { x: number; y: number };
  timeout?: number;
}): Promise<void>

// Usage examples
await page.getByRole('textbox').focus();
await page.getByRole('button').hover();
```

## Mocking Patterns and Setup Functions

### Component Rendering with Props
```typescript
// Basic component rendering
render<T>(
  component: ComponentType<T>,
  props?: T,
  options?: { context?: Map<any, any> }
): RenderResult

// Usage examples
render(Button, {
  variant: 'primary',
  is_disabled: false,
  click_handler: vi.fn(),
});

render(Input, {
  input_type: 'email' as const,
  label_text: 'Email',
  current_value: 'test@example.com',
  error_message: 'Invalid email',
  is_required: true,
});
```

### Event Handler Mocking
```typescript
// Mock function creation with types
vi.fn(): MockFunction
vi.fn<TArgs extends any[], TReturn>(
  implementation?: (...args: TArgs) => TReturn
): MockFunction<TArgs, TReturn>

// Usage examples
const handle_click = vi.fn();
const handle_submit = vi.fn((data: FormData) => Promise.resolve());

render(Button, {
  onclick: handle_click,
  onsubmit: handle_submit,
});

// Verify calls
expect(handle_click).toHaveBeenCalledOnce();
expect(handle_submit).toHaveBeenCalledWith(expect.any(FormData));
```

### Module Mocking
```typescript
// Mock entire modules
vi.mock(path: string, factory?: () => any): void

// Mock with import original
vi.mock(path: string, factory?: (importOriginal: () => Promise<any>) => any): void

// Usage examples
vi.mock('$lib/api', () => ({
  fetch_user_data: vi.fn(() => Promise.resolve({ user_id: 1 })),
  send_analytics: vi.fn(),
}));

vi.mock('$lib/utils', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...actual,
    validate_email: vi.fn(() => true),
  };
});
```

### Component Mocking
```typescript
// Mock Svelte components
vi.mock('./child-component.svelte', () => ({
  default: vi.fn().mockImplementation(() => ({
    $$: {},
    $set: vi.fn(),
    $destroy: vi.fn(),
    $on: vi.fn(),
  })),
}));
```

### Spy Functions
```typescript
// Spy on existing functions
vi.spyOn(object: any, method: string | symbol): MockFunction

// Usage examples
const validate_spy = vi.spyOn(utils, 'validate_email');
const console_error = vi.spyOn(console, 'error').mockImplementation(() => {});

// Restore spies
validate_spy.mockRestore();
```

## SSR Testing Methods and Utilities

### Server-Side Rendering
```typescript
// SSR render function
render(
  Component: ComponentType,
  options?: {
    props?: Record<string, any>;
    context?: Map<any, any>;
  }
): {
  body: string;
  head: string;
}

// Usage examples
const { body, head } = render(Component);

const { body, head } = render(Component, {
  props: {
    page_title: 'Test Page',
    user_data: { name: 'Test User' },
  }
});

const { body, head } = render(Component, {
  props: {},
  context: new Map([['theme', 'dark']]),
});
```

### SSR Assertions
```typescript
// Content structure testing (avoid implementation details)
expect(body: string).toContain(substring: string): void
expect(head: string).toContain(substring: string): void

// Usage examples - test semantic structure
expect(body).toContain('<h1>Welcome</h1>');
expect(body).toContain('role="main"');
expect(body).toContain('aria-label="Navigation"');

// Head content for SEO
expect(head).toContain('<title>Page Title</title>');
expect(head).toContain('<meta name="description"');

// Test CSS classes for styling
expect(body).toContain('text-success');
expect(body).toContain('btn-primary');
```

### SSR Error Handling
```typescript
// Test SSR doesn't throw errors
expect(() => {
  render(ComponentName);
}).not.toThrow(): void

// Test with error props
expect(() => {
  render(BrokenComponent, { props: { cause_error: true } });
}).toThrow(errorMatcher?: string | RegExp | Error): void
```

## Svelte 5 Runes Testing

### State Testing
```typescript
// $state testing in .test.svelte.ts files only
let count = $state(initialValue: T): T
let doubled = $derived(expression: T): T

// Always use untrack for $derived values
untrack<T>(fn: () => T): T
flushSync(): void

// Usage examples
test('reactive state updates', () => {
  let count = $state(0);
  expect(count).toBe(0);

  count = 5;
  expect(count).toBe(5);
});

test('derived state calculation', () => {
  let count = $state(0);
  let doubled = $derived(count * 2);

  // CRITICAL: Always untrack derived values
  expect(untrack(() => doubled)).toBe(0);

  count = 5;
  flushSync(); // Force synchronous update
  expect(untrack(() => doubled)).toBe(10);
});
```

### Complex Derived State
```typescript
// Test form state with multiple derived values
test('form validation state', () => {
  let email = $state('');
  let submit_attempted = $state(false);
  let email_touched = $state(false);

  const email_validation = $derived(validate_email(email));
  const show_email_error = $derived(submit_attempted || email_touched);
  const email_error = $derived(
    show_email_error && !email_validation.is_valid
      ? email_validation.error_message
      : ''
  );

  // Test initial state
  expect(untrack(() => show_email_error)).toBe(false);
  expect(untrack(() => email_error)).toBe('');

  // Test after interaction
  email = 'invalid';
  email_touched = true;
  flushSync();

  expect(untrack(() => show_email_error)).toBe(true);
  expect(untrack(() => email_error)).toBe('Invalid format');
});
```

### Effect Testing
```typescript
// $effect testing with spy functions
$effect(fn: () => void | (() => void)): void

// Usage example
test('effect runs on state change', () => {
  const effect_spy = vi.fn();
  let count = $state(0);

  $effect(() => {
    effect_spy(count);
  });

  count = 1;
  flushSync();

  expect(effect_spy).toHaveBeenCalledWith(1);
});
```

## Configuration and Setup Options

### Vitest Browser Configuration
```typescript
// vite.config.ts configuration
export default defineConfig({
  test: {
    projects: [
      {
        test: {
          name: 'client',
          environment: 'browser',
          testTimeout: 2000, // Browser test timeout
          browser: {
            enabled: true,
            provider: 'playwright',
            instances: [
              { browser: 'chromium' },
              { browser: 'firefox' },
              { browser: 'webkit' },
            ],
            // Performance options
            headless: true,
            slowMo: 100, // Debugging
            screenshot: 'only-on-failure',
          },
          include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
          exclude: ['src/lib/server/**'],
          setupFiles: ['./vitest-setup-client.ts'],
        },
      },
      {
        test: {
          name: 'ssr',
          environment: 'node',
          include: ['src/**/*.ssr.{test,spec}.{js,ts}'],
        },
      },
    ],
  },
});
```

### Test Environment Setup
```typescript
// Environment variables and timeouts
process.env.NODE_ENV = 'test';
process.env.API_URL = 'http://localhost:3000';

// Test-specific configuration
test(
  'slow integration test',
  async () => {
    // Test implementation
  },
  { timeout: 30000 } // 30 second timeout
);

// Concurrent execution
test.concurrent('parallel test', async () => {
  // Runs in parallel with other concurrent tests
});
```

### Custom Matchers and Utilities
```typescript
// Extend expect with domain-specific matchers
expect.extend({
  to_have_validation_error(
    received: any,
    expected_error: string
  ) {
    const error_element = page.getByText(expected_error);
    const element_exists = !!error_element;

    return {
      pass: element_exists,
      message: () =>
        element_exists
          ? `Expected not to have validation error: ${expected_error}`
          : `Expected to have validation error: ${expected_error}`,
    };
  },
});

// Custom render helper
const render_with_theme = (Component: any, props = {}) => {
  return render(Component, {
    ...props,
    context: new Map([['theme', 'dark']]),
  });
};

// Form testing helper
const fill_form_data = async (form_data: Record<string, string>) => {
  for (const [field_name, field_value] of Object.entries(form_data)) {
    await page.getByLabelText(field_name).fill(field_value);
  }
};
```

### Wait Utilities and Timeouts
```typescript
// Element waiting (built into locators)
await expect
  .element(page.getByText('Loading complete'))
  .toBeInTheDocument({ timeout?: number }): Promise<void>

// Custom conditions
page.waitForFunction(
  pageFunction: () => boolean,
  options?: { timeout?: number }
): Promise<void>

// Network requests
page.waitForResponse(
  urlOrPredicate: string | RegExp | ((response: Response) => boolean),
  options?: { timeout?: number }
): Promise<Response>

// Usage examples
await expect
  .element(page.getByText('Data loaded'))
  .toBeInTheDocument({ timeout: 10000 });

await page.waitForFunction(() => window.data_loaded === true);
await page.waitForResponse('**/api/user-data');
```